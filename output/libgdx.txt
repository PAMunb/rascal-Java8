home/input.csv
INFO:root:  RJTL: Loading and start rejuvenation process...
Version: 0.28.2
INFO: detected |lib://rascal| at |jar+file:///home/rascal-Java8/rascal-shell-stable.jar!/|
INFO: resolved |lib://rascal| at |jar+file:///home/rascal-Java8/rascal-shell-stable.jar!/|
[Project Analyzer] project: libgdx
Creating log file at: /output/log-20230115024733
Processing libgdx...
  78 of 2379 processed succesfully!
  82 of 2379 processed succesfully!
  87 of 2379 processed succesfully!
  93 of 2379 processed succesfully!
  159 of 2379 processed succesfully!
  438 of 2379 processed succesfully!
  467 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/math/collision/OrientedBoundingBox.java|
ParseError(|unknown:///|(3189,1,<97,32>,<97,33>))
  601 of 2379 processed succesfully!
  693 of 2379 processed succesfully!
  725 of 2379 processed succesfully!
  919 of 2379 processed succesfully!
  964 of 2379 processed succesfully!
throws in annonymous
[0,0,0,0,0,1]
  1237 of 2379 processed succesfully!
  1259 of 2379 processed succesfully!
  1340 of 2379 processed succesfully!
  1352 of 2379 processed succesfully!
  1356 of 2379 processed succesfully!
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/collision/RayCastOutput.java|
Ambiguity(|unknown:///|(0,1979,<1,0>,<45,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.collision;\n\nimport org.jbox2d.common.Vec2;\n\n// updated to rev 100\n/** Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from b2RayCastInput. */\npublic class RayCastOutput {\n\tpublic final Vec2 normal;\n\tpublic float fraction;\n\n\tpublic RayCastOutput () {\n\t\tnormal = new Vec2();\n\t\tfraction = 0;\n\t}\n\n\tpublic void set (final RayCastOutput rco) {\n\t\tnormal.set(rco.normal);\n\t\tfraction = rco.fraction;\n\t}\n};\n")
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/dynamics/World.java|
Ambiguity(|unknown:///|(0,56587,<1,0>,<1895,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.dynamics;\n\nimport org.jbox2d.callbacks.ContactFilter;\nimport org.jbox2d.callbacks.ContactListener;\nimport org.jbox2d.callbacks.DebugDraw;\nimport org.jbox2d.callbacks.DestructionListener;\nimport org.jbox2d.callbacks.ParticleDestructionListener;\nimport org.jbox2d.callbacks.ParticleQueryCallback;\nimport org.jbox2d.callbacks.ParticleRaycastCallback;\nimport org.jbox2d.callbacks.QueryCallback;\nimport org.jbox2d.callbacks.RayCastCallback;\nimport org.jbox2d.callbacks.TreeCallback;\nimport org.jbox2d.callbacks.TreeRayCastCallback;\nimport org.jbox2d.collision.AABB;\nimport org.jbox2d.collision.RayCastInput;\nimport org.jbox2d.collision.RayCastOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIInput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutputState;\nimport org.jbox2d.collision.broadphase.BroadPhase;\nimport org.jbox2d.collision.broadphase.BroadPhaseStrategy;\nimport org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer;\nimport org.jbox2d.collision.broadphase.DynamicTree;\nimport org.jbox2d.collision.shapes.ChainShape;\nimport org.jbox2d.collision.shapes.CircleShape;\nimport org.jbox2d.collision.shapes.EdgeShape;\nimport org.jbox2d.collision.shapes.PolygonShape;\nimport org.jbox2d.collision.shapes.Shape;\nimport org.jbox2d.collision.shapes.ShapeType;\nimport org.jbox2d.common.Color3f;\nimport org.jbox2d.common.MathUtils;\nimport org.jbox2d.common.Settings;\nimport org.jbox2d.common.Sweep;\nimport org.jbox2d.common.Timer;\nimport org.jbox2d.common.Transform;\nimport org.jbox2d.common.Vec2;\nimport org.jbox2d.dynamics.contacts.Contact;\nimport org.jbox2d.dynamics.contacts.ContactEdge;\nimport org.jbox2d.dynamics.contacts.ContactRegister;\nimport org.jbox2d.dynamics.joints.Joint;\nimport org.jbox2d.dynamics.joints.JointDef;\nimport org.jbox2d.dynamics.joints.JointEdge;\nimport org.jbox2d.dynamics.joints.PulleyJoint;\nimport org.jbox2d.particle.ParticleBodyContact;\nimport org.jbox2d.particle.ParticleColor;\nimport org.jbox2d.particle.ParticleContact;\nimport org.jbox2d.particle.ParticleDef;\nimport org.jbox2d.particle.ParticleGroup;\nimport org.jbox2d.particle.ParticleGroupDef;\nimport org.jbox2d.particle.ParticleSystem;\nimport org.jbox2d.pooling.IDynamicStack;\nimport org.jbox2d.pooling.IWorldPool;\nimport org.jbox2d.pooling.arrays.Vec2Array;\nimport org.jbox2d.pooling.normal.DefaultWorldPool;\n\n/** The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n * memory management facilities.\n * \n * @author Daniel Murphy */\npublic class World {\n\tpublic static final int WORLD_POOL_SIZE = 100;\n\tpublic static final int WORLD_POOL_CONTAINER_SIZE = 10;\n\n\tpublic static final int NEW_FIXTURE = 0x0001;\n\tpublic static final int LOCKED = 0x0002;\n\tpublic static final int CLEAR_FORCES = 0x0004;\n\n\t// statistics gathering\n\tpublic int activeContacts = 0;\n\tpublic int contactPoolCount = 0;\n\n\tprotected int m_flags;\n\n\tprotected ContactManager m_contactManager;\n\n\tprivate Body m_bodyList;\n\tprivate Joint m_jointList;\n\n\tprivate int m_bodyCount;\n\tprivate int m_jointCount;\n\n\tprivate final Vec2 m_gravity = new Vec2();\n\tprivate boolean m_allowSleep;\n\n\t// private Body m_groundBody;\n\n\tprivate DestructionListener m_destructionListener;\n\tprivate ParticleDestructionListener m_particleDestructionListener;\n\tprivate DebugDraw m_debugDraw;\n\n\tprivate final IWorldPool pool;\n\n\t/** This is used to compute the time step ratio to support a variable time step. */\n\tprivate float m_inv_dt0;\n\n\t// these are for debugging the solver\n\tprivate boolean m_warmStarting;\n\tprivate boolean m_continuousPhysics;\n\tprivate boolean m_subStepping;\n\n\tprivate boolean m_stepComplete;\n\n\tprivate Profile m_profile;\n\n\tprivate ParticleSystem m_particleSystem;\n\n\tprivate ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity, IWorldPool pool) {\n\t\tthis(gravity, pool, new DynamicTree());\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhaseStrategy strategy) {\n\t\tthis(gravity, pool, new DefaultBroadPhaseBuffer(strategy));\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhase broadPhase) {\n\t\tthis.pool = pool;\n\t\tm_destructionListener = null;\n\t\tm_debugDraw = null;\n\n\t\tm_bodyList = null;\n\t\tm_jointList = null;\n\n\t\tm_bodyCount = 0;\n\t\tm_jointCount = 0;\n\n\t\tm_warmStarting = true;\n\t\tm_continuousPhysics = true;\n\t\tm_subStepping = false;\n\t\tm_stepComplete = true;\n\n\t\tm_allowSleep = true;\n\t\tm_gravity.set(gravity);\n\n\t\tm_flags = CLEAR_FORCES;\n\n\t\tm_inv_dt0 = 0f;\n\n\t\tm_contactManager = new ContactManager(this, broadPhase);\n\t\tm_profile = new Profile();\n\n\t\tm_particleSystem = new ParticleSystem(this);\n\n\t\tinitializeRegisters();\n\t}\n\n\tpublic void setAllowSleep (boolean flag) {\n\t\tif (flag == m_allowSleep) {\n\t\t\treturn;\n\t\t}\n\n\t\tm_allowSleep = flag;\n\t\tif (m_allowSleep == false) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.setAwake(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSubStepping (boolean subStepping) {\n\t\tthis.m_subStepping = subStepping;\n\t}\n\n\tpublic boolean isSubStepping () {\n\t\treturn m_subStepping;\n\t}\n\n\tpublic boolean isAllowSleep () {\n\t\treturn m_allowSleep;\n\t}\n\n\tprivate void addType (IDynamicStack\<Contact\> creator, ShapeType type1, ShapeType type2) {\n\t\tContactRegister register = new ContactRegister();\n\t\tregister.creator = creator;\n\t\tregister.primary = true;\n\t\tcontactStacks[type1.ordinal()][type2.ordinal()] = register;\n\n\t\tif (type1 != type2) {\n\t\t\tContactRegister register2 = new ContactRegister();\n\t\t\tregister2.creator = creator;\n\t\t\tregister2.primary = false;\n\t\t\tcontactStacks[type2.ordinal()][type1.ordinal()] = register2;\n\t\t}\n\t}\n\n\tprivate void initializeRegisters () {\n\t\taddType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);\n\t\taddType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);\n\t\taddType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);\n\t\taddType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);\n\t\taddType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);\n\t}\n\n\tpublic DestructionListener getDestructionListener () {\n\t\treturn m_destructionListener;\n\t}\n\n\tpublic ParticleDestructionListener getParticleDestructionListener () {\n\t\treturn m_particleDestructionListener;\n\t}\n\n\tpublic void setParticleDestructionListener (ParticleDestructionListener listener) {\n\t\tm_particleDestructionListener = listener;\n\t}\n\n\tpublic Contact popContact (Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {\n\t\tfinal ShapeType type1 = fixtureA.getType();\n\t\tfinal ShapeType type2 = fixtureB.getType();\n\n\t\tfinal ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];\n\t\tif (reg != null) {\n\t\t\tif (reg.primary) {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureA, indexA, fixtureB, indexB);\n\t\t\t\treturn c;\n\t\t\t} else {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureB, indexB, fixtureA, indexA);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void pushContact (Contact contact) {\n\t\tFixture fixtureA = contact.getFixtureA();\n\t\tFixture fixtureB = contact.getFixtureB();\n\n\t\tif (contact.m_manifold.pointCount \> 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {\n\t\t\tfixtureA.getBody().setAwake(true);\n\t\t\tfixtureB.getBody().setAwake(true);\n\t\t}\n\n\t\tShapeType type1 = fixtureA.getType();\n\t\tShapeType type2 = fixtureB.getType();\n\n\t\tIDynamicStack\<Contact\> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;\n\t\tcreator.push(contact);\n\t}\n\n\tpublic IWorldPool getPool () {\n\t\treturn pool;\n\t}\n\n\t/** Register a destruction listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setDestructionListener (DestructionListener listener) {\n\t\tm_destructionListener = listener;\n\t}\n\n\t/** Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n\t * (_defaultFilter). The listener is owned by you and must remain in scope.\n\t * \n\t * @param filter */\n\tpublic void setContactFilter (ContactFilter filter) {\n\t\tm_contactManager.m_contactFilter = filter;\n\t}\n\n\t/** Register a contact event listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setContactListener (ContactListener listener) {\n\t\tm_contactManager.m_contactListener = listener;\n\t}\n\n\t/** Register a routine for debug drawing. The debug draw functions are called inside with World.DrawDebugData method. The debug\n\t * draw object is owned by you and must remain in scope.\n\t * \n\t * @param debugDraw */\n\tpublic void setDebugDraw (DebugDraw debugDraw) {\n\t\tm_debugDraw = debugDraw;\n\t}\n\n\t/** create a rigid body given a definition. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Body createBody (BodyDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\t// TODO djm pooling\n\t\tBody b = new Body(def, this);\n\n\t\t// add to world doubly linked list\n\t\tb.m_prev = null;\n\t\tb.m_next = m_bodyList;\n\t\tif (m_bodyList != null) {\n\t\t\tm_bodyList.m_prev = b;\n\t\t}\n\t\tm_bodyList = b;\n\t\t++m_bodyCount;\n\n\t\treturn b;\n\t}\n\n\t/** destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n\t * callbacks.\n\t * \n\t * @warning This automatically deletes all associated shapes and joints.\n\t * @warning This function is locked during callbacks.\n\t * @param body */\n\tpublic void destroyBody (Body body) {\n\t\tassert (m_bodyCount \> 0);\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete the attached joints.\n\t\tJointEdge je = body.m_jointList;\n\t\twhile (je != null) {\n\t\t\tJointEdge je0 = je;\n\t\t\tje = je.next;\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(je0.joint);\n\t\t\t}\n\n\t\t\tdestroyJoint(je0.joint);\n\n\t\t\tbody.m_jointList = je;\n\t\t}\n\t\tbody.m_jointList = null;\n\n\t\t// Delete the attached contacts.\n\t\tContactEdge ce = body.m_contactList;\n\t\twhile (ce != null) {\n\t\t\tContactEdge ce0 = ce;\n\t\t\tce = ce.next;\n\t\t\tm_contactManager.destroy(ce0.contact);\n\t\t}\n\t\tbody.m_contactList = null;\n\n\t\tFixture f = body.m_fixtureList;\n\t\twhile (f != null) {\n\t\t\tFixture f0 = f;\n\t\t\tf = f.m_next;\n\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(f0);\n\t\t\t}\n\n\t\t\tf0.destroyProxies(m_contactManager.m_broadPhase);\n\t\t\tf0.destroy();\n\t\t\t// TODO djm recycle fixtures (here or in that destroy method)\n\t\t\tbody.m_fixtureList = f;\n\t\t\tbody.m_fixtureCount -= 1;\n\t\t}\n\t\tbody.m_fixtureList = null;\n\t\tbody.m_fixtureCount = 0;\n\n\t\t// Remove world body list.\n\t\tif (body.m_prev != null) {\n\t\t\tbody.m_prev.m_next = body.m_next;\n\t\t}\n\n\t\tif (body.m_next != null) {\n\t\t\tbody.m_next.m_prev = body.m_prev;\n\t\t}\n\n\t\tif (body == m_bodyList) {\n\t\t\tm_bodyList = body.m_next;\n\t\t}\n\n\t\t--m_bodyCount;\n\t\t// TODO djm recycle body\n\t}\n\n\t/** create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected\n\t * bodies to cease colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Joint createJoint (JointDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJoint j = Joint.create(this, def);\n\n\t\t// Connect to the world list.\n\t\tj.m_prev = null;\n\t\tj.m_next = m_jointList;\n\t\tif (m_jointList != null) {\n\t\t\tm_jointList.m_prev = j;\n\t\t}\n\t\tm_jointList = j;\n\t\t++m_jointCount;\n\n\t\t// Connect to the bodies\' doubly linked lists.\n\t\tj.m_edgeA.joint = j;\n\t\tj.m_edgeA.other = j.getBodyB();\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = j.getBodyA().m_jointList;\n\t\tif (j.getBodyA().m_jointList != null) {\n\t\t\tj.getBodyA().m_jointList.prev = j.m_edgeA;\n\t\t}\n\t\tj.getBodyA().m_jointList = j.m_edgeA;\n\n\t\tj.m_edgeB.joint = j;\n\t\tj.m_edgeB.other = j.getBodyA();\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = j.getBodyB().m_jointList;\n\t\tif (j.getBodyB().m_jointList != null) {\n\t\t\tj.getBodyB().m_jointList.prev = j.m_edgeB;\n\t\t}\n\t\tj.getBodyB().m_jointList = j.m_edgeB;\n\n\t\tBody bodyA = def.bodyA;\n\t\tBody bodyB = def.bodyB;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (def.collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\n\t\t// Note: creating a joint doesn\'t wake the bodies.\n\n\t\treturn j;\n\t}\n\n\t/** destroy a joint. This may cause the connected bodies to begin colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param joint */\n\tpublic void destroyJoint (Joint j) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\tboolean collideConnected = j.getCollideConnected();\n\n\t\t// Remove from the doubly linked list.\n\t\tif (j.m_prev != null) {\n\t\t\tj.m_prev.m_next = j.m_next;\n\t\t}\n\n\t\tif (j.m_next != null) {\n\t\t\tj.m_next.m_prev = j.m_prev;\n\t\t}\n\n\t\tif (j == m_jointList) {\n\t\t\tm_jointList = j.m_next;\n\t\t}\n\n\t\t// Disconnect from island graph.\n\t\tBody bodyA = j.getBodyA();\n\t\tBody bodyB = j.getBodyB();\n\n\t\t// Wake up connected bodies.\n\t\tbodyA.setAwake(true);\n\t\tbodyB.setAwake(true);\n\n\t\t// Remove from body 1.\n\t\tif (j.m_edgeA.prev != null) {\n\t\t\tj.m_edgeA.prev.next = j.m_edgeA.next;\n\t\t}\n\n\t\tif (j.m_edgeA.next != null) {\n\t\t\tj.m_edgeA.next.prev = j.m_edgeA.prev;\n\t\t}\n\n\t\tif (j.m_edgeA == bodyA.m_jointList) {\n\t\t\tbodyA.m_jointList = j.m_edgeA.next;\n\t\t}\n\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = null;\n\n\t\t// Remove from body 2\n\t\tif (j.m_edgeB.prev != null) {\n\t\t\tj.m_edgeB.prev.next = j.m_edgeB.next;\n\t\t}\n\n\t\tif (j.m_edgeB.next != null) {\n\t\t\tj.m_edgeB.next.prev = j.m_edgeB.prev;\n\t\t}\n\n\t\tif (j.m_edgeB == bodyB.m_jointList) {\n\t\t\tbodyB.m_jointList = j.m_edgeB.next;\n\t\t}\n\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = null;\n\n\t\tJoint.destroy(j);\n\n\t\tassert (m_jointCount \> 0);\n\t\t--m_jointCount;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\t}\n\n\t// djm pooling\n\tprivate final TimeStep step = new TimeStep();\n\tprivate final Timer stepTimer = new Timer();\n\tprivate final Timer tempTimer = new Timer();\n\n\t/** Take a time step. This performs collision detection, integration, and constraint solution.\n\t * \n\t * @param timeStep the amount of time to simulate, this should not vary.\n\t * @param velocityIterations for the velocity constraint solver.\n\t * @param positionIterations for the position constraint solver. */\n\tpublic void step (float dt, int velocityIterations, int positionIterations) {\n\t\tstepTimer.reset();\n\t\ttempTimer.reset();\n\t\t// log.debug(\"Starting step\");\n\t\t// If new fixtures were added, we need to find the new contacts.\n\t\tif ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\n\t\t\t// log.debug(\"There\'s a new fixture, lets look for new contacts\");\n\t\t\tm_contactManager.findNewContacts();\n\t\t\tm_flags &= ~NEW_FIXTURE;\n\t\t}\n\n\t\tm_flags |= LOCKED;\n\n\t\tstep.dt = dt;\n\t\tstep.velocityIterations = velocityIterations;\n\t\tstep.positionIterations = positionIterations;\n\t\tif (dt \> 0.0f) {\n\t\t\tstep.inv_dt = 1.0f / dt;\n\t\t} else {\n\t\t\tstep.inv_dt = 0.0f;\n\t\t}\n\n\t\tstep.dtRatio = m_inv_dt0 * dt;\n\n\t\tstep.warmStarting = m_warmStarting;\n\t\tm_profile.stepInit.record(tempTimer.getMilliseconds());\n\n\t\t// Update contacts. This is where some contacts are destroyed.\n\t\ttempTimer.reset();\n\t\tm_contactManager.collide();\n\t\tm_profile.collide.record(tempTimer.getMilliseconds());\n\n\t\t// Integrate velocities, solve velocity constraints, and integrate positions.\n\t\tif (m_stepComplete && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tm_particleSystem.solve(step); // Particle Simulation\n\t\t\tm_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\n\t\t\ttempTimer.reset();\n\t\t\tsolve(step);\n\t\t\tm_profile.solve.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\t// Handle TOI events.\n\t\tif (m_continuousPhysics && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tsolveTOI(step);\n\t\t\tm_profile.solveTOI.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\tif (step.dt \> 0.0f) {\n\t\t\tm_inv_dt0 = step.inv_dt;\n\t\t}\n\n\t\tif ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\n\t\t\tclearForces();\n\t\t}\n\n\t\tm_flags &= ~LOCKED;\n\t\t// log.debug(\"ending step\");\n\n\t\tm_profile.step.record(stepTimer.getMilliseconds());\n\t}\n\n\t/** Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless\n\t * you are performing sub-steps. By default, forces will be automatically cleared, so you don\'t need to call this function.\n\t * \n\t * @see setAutoClearForces */\n\tpublic void clearForces () {\n\t\tfor (Body body = m_bodyList; body != null; body = body.getNext()) {\n\t\t\tbody.m_force.setZero();\n\t\t\tbody.m_torque = 0.0f;\n\t\t}\n\t}\n\n\tprivate final Color3f color = new Color3f();\n\tprivate final Transform xf = new Transform();\n\tprivate final Vec2 cA = new Vec2();\n\tprivate final Vec2 cB = new Vec2();\n\tprivate final Vec2Array avs = new Vec2Array();\n\n\t/** Call this to draw shapes and other debug draw data. */\n\tpublic void drawDebugData () {\n\t\tif (m_debugDraw == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint flags = m_debugDraw.getFlags();\n\t\tboolean wireframe = (flags & DebugDraw.e_wireframeDrawingBit) != 0;\n\n\t\tif ((flags & DebugDraw.e_shapeBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.STATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.9f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.KINEMATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.9f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.isAwake() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.5f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolor.set(0.9f, 0.7f, 0.7f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawParticleSystem(m_particleSystem);\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_jointBit) != 0) {\n\t\t\tfor (Joint j = m_jointList; j != null; j = j.getNext()) {\n\t\t\t\tdrawJoint(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_pairBit) != 0) {\n\t\t\tcolor.set(0.3f, 0.9f, 0.9f);\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.getNext()) {\n\t\t\t\tFixture fixtureA = c.getFixtureA();\n\t\t\t\tFixture fixtureB = c.getFixtureB();\n\t\t\t\tfixtureA.getAABB(c.getChildIndexA()).getCenterToOut(cA);\n\t\t\t\tfixtureB.getAABB(c.getChildIndexB()).getCenterToOut(cB);\n\t\t\t\tm_debugDraw.drawSegment(cA, cB, color);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_aabbBit) != 0) {\n\t\t\tcolor.set(0.9f, 0.3f, 0.9f);\n\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tfor (int i = 0; i \< f.m_proxyCount; ++i) {\n\t\t\t\t\t\tFixtureProxy proxy = f.m_proxies[i];\n\t\t\t\t\t\tAABB aabb = m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);\n\t\t\t\t\t\tif (aabb != null) {\n\t\t\t\t\t\t\tVec2[] vs = avs.get(4);\n\t\t\t\t\t\t\tvs[0].set(aabb.lowerBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[1].set(aabb.upperBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[2].set(aabb.upperBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tvs[3].set(aabb.lowerBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tm_debugDraw.drawPolygon(vs, 4, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_centerOfMassBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\txf.p.set(b.getWorldCenter());\n\t\t\t\tm_debugDraw.drawTransform(xf);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_dynamicTreeBit) != 0) {\n\t\t\tm_contactManager.m_broadPhase.drawTree(m_debugDraw);\n\t\t}\n\n\t\tm_debugDraw.flush();\n\t}\n\n\tprivate final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();\n\n\t/** Query the world for all fixtures that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t}\n\n\t/** Query the world for all fixtures and particles that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\t/** Query the world for all particles that potentially overlap the provided AABB.\n\t * \n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (ParticleQueryCallback particleCallback, AABB aabb) {\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\tprivate final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();\n\tprivate final RayCastInput input = new RayCastInput();\n\n\t/** Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t}\n\n\t/** Ray-cast the world for all fixtures and particles in the path of the ray. Your callback controls whether you get the\n\t * closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Ray-cast the world for all particles in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points.\n\t * \n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Get the world body list. With the returned body, use Body.getNext to get the next body in the world list. A null body\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world body list. */\n\tpublic Body getBodyList () {\n\t\treturn m_bodyList;\n\t}\n\n\t/** Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in the world list. A null joint\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world joint list. */\n\tpublic Joint getJointList () {\n\t\treturn m_jointList;\n\t}\n\n\t/** Get the world contact list. With the returned contact, use Contact.getNext to get the next contact in the world list. A\n\t * null contact indicates the end of the list.\n\t * \n\t * @return the head of the world contact list.\n\t * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener to avoid missing contacts. */\n\tpublic Contact getContactList () {\n\t\treturn m_contactManager.m_contactList;\n\t}\n\n\tpublic boolean isSleepingAllowed () {\n\t\treturn m_allowSleep;\n\t}\n\n\tpublic void setSleepingAllowed (boolean sleepingAllowed) {\n\t\tm_allowSleep = sleepingAllowed;\n\t}\n\n\t/** Enable/disable warm starting. For testing.\n\t * \n\t * @param flag */\n\tpublic void setWarmStarting (boolean flag) {\n\t\tm_warmStarting = flag;\n\t}\n\n\tpublic boolean isWarmStarting () {\n\t\treturn m_warmStarting;\n\t}\n\n\t/** Enable/disable continuous physics. For testing.\n\t * \n\t * @param flag */\n\tpublic void setContinuousPhysics (boolean flag) {\n\t\tm_continuousPhysics = flag;\n\t}\n\n\tpublic boolean isContinuousPhysics () {\n\t\treturn m_continuousPhysics;\n\t}\n\n\t/** Get the number of broad-phase proxies.\n\t * \n\t * @return */\n\tpublic int getProxyCount () {\n\t\treturn m_contactManager.m_broadPhase.getProxyCount();\n\t}\n\n\t/** Get the number of bodies.\n\t * \n\t * @return */\n\tpublic int getBodyCount () {\n\t\treturn m_bodyCount;\n\t}\n\n\t/** Get the number of joints.\n\t * \n\t * @return */\n\tpublic int getJointCount () {\n\t\treturn m_jointCount;\n\t}\n\n\t/** Get the number of contacts (each may have 0 or more contact points).\n\t * \n\t * @return */\n\tpublic int getContactCount () {\n\t\treturn m_contactManager.m_contactCount;\n\t}\n\n\t/** Gets the height of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeHeight () {\n\t\treturn m_contactManager.m_broadPhase.getTreeHeight();\n\t}\n\n\t/** Gets the balance of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeBalance () {\n\t\treturn m_contactManager.m_broadPhase.getTreeBalance();\n\t}\n\n\t/** Gets the quality of the dynamic tree\n\t * \n\t * @return */\n\tpublic float getTreeQuality () {\n\t\treturn m_contactManager.m_broadPhase.getTreeQuality();\n\t}\n\n\t/** Change the global gravity vector.\n\t * \n\t * @param gravity */\n\tpublic void setGravity (Vec2 gravity) {\n\t\tm_gravity.set(gravity);\n\t}\n\n\t/** Get the global gravity vector.\n\t * \n\t * @return */\n\tpublic Vec2 getGravity () {\n\t\treturn m_gravity;\n\t}\n\n\t/** Is the world locked (in the middle of a time step).\n\t * \n\t * @return */\n\tpublic boolean isLocked () {\n\t\treturn (m_flags & LOCKED) == LOCKED;\n\t}\n\n\t/** Set flag to control automatic clearing of forces after each time step.\n\t * \n\t * @param flag */\n\tpublic void setAutoClearForces (boolean flag) {\n\t\tif (flag) {\n\t\t\tm_flags |= CLEAR_FORCES;\n\t\t} else {\n\t\t\tm_flags &= ~CLEAR_FORCES;\n\t\t}\n\t}\n\n\t/** Get the flag that controls automatic clearing of forces after each time step.\n\t * \n\t * @return */\n\tpublic boolean getAutoClearForces () {\n\t\treturn (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\n\t}\n\n\t/** Get the contact manager for testing purposes\n\t * \n\t * @return */\n\tpublic ContactManager getContactManager () {\n\t\treturn m_contactManager;\n\t}\n\n\tpublic Profile getProfile () {\n\t\treturn m_profile;\n\t}\n\n\tprivate final Island island = new Island();\n\tprivate Body[] stack = new Body[10]; // TODO djm find a good initial stack number;\n\tprivate final Timer broadphaseTimer = new Timer();\n\n\tprivate void solve (TimeStep step) {\n\t\tm_profile.solveInit.startAccum();\n\t\tm_profile.solveVelocity.startAccum();\n\t\tm_profile.solvePosition.startAccum();\n\n\t\t// update previous transforms\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_xf0.set(b.m_xf);\n\t\t}\n\n\t\t// Size the island for the worst case.\n\t\tisland.init(m_bodyCount, m_contactManager.m_contactCount, m_jointCount, m_contactManager.m_contactListener);\n\n\t\t// Clear all the island flags.\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t}\n\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\tc.m_flags &= ~Contact.ISLAND_FLAG;\n\t\t}\n\t\tfor (Joint j = m_jointList; j != null; j = j.m_next) {\n\t\t\tj.m_islandFlag = false;\n\t\t}\n\n\t\t// Build and simulate all awake islands.\n\t\tint stackSize = m_bodyCount;\n\t\tif (stack.length \< stackSize) {\n\t\t\tstack = new Body[stackSize];\n\t\t}\n\t\tfor (Body seed = m_bodyList; seed != null; seed = seed.m_next) {\n\t\t\tif ((seed.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (seed.isAwake() == false || seed.isActive() == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The seed can be dynamic or kinematic.\n\t\t\tif (seed.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Reset island and stack.\n\t\t\tisland.clear();\n\t\t\tint stackCount = 0;\n\t\t\tstack[stackCount++] = seed;\n\t\t\tseed.m_flags |= Body.e_islandFlag;\n\n\t\t\t// Perform a depth first search (DFS) on the constraint graph.\n\t\t\twhile (stackCount \> 0) {\n\t\t\t\t// Grab the next body off the stack and add it to the island.\n\t\t\t\tBody b = stack[--stackCount];\n\t\t\t\tassert (b.isActive() == true);\n\t\t\t\tisland.add(b);\n\n\t\t\t\t// Make sure the body is awake.\n\t\t\t\tb.setAwake(true);\n\n\t\t\t\t// To keep islands as small as possible, we don\'t\n\t\t\t\t// propagate islands across static bodies.\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Search all contacts connected to this body.\n\t\t\t\tfor (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t// Has this contact already been added to an island?\n\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Is this contact solid and touching?\n\t\t\t\t\tif (contact.isEnabled() == false || contact.isTouching() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip sensors.\n\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(contact);\n\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t\t\tBody other = ce.other;\n\n\t\t\t\t\t// Was the other body already added to this island?\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\n\t\t\t\t// Search all joints connect to this body.\n\t\t\t\tfor (JointEdge je = b.m_jointList; je != null; je = je.next) {\n\t\t\t\t\tif (je.joint.m_islandFlag == true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody other = je.other;\n\n\t\t\t\t\t// Don\'t simulate joints connected to inactive bodies.\n\t\t\t\t\tif (other.isActive() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(je.joint);\n\t\t\t\t\tje.joint.m_islandFlag = true;\n\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tisland.solve(m_profile, step, m_gravity, m_allowSleep);\n\n\t\t\t// Post solve cleanup.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\t// Allow static bodies to participate in other islands.\n\t\t\t\tBody b = island.m_bodies[i];\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm_profile.solveInit.endAccum();\n\t\tm_profile.solveVelocity.endAccum();\n\t\tm_profile.solvePosition.endAccum();\n\n\t\tbroadphaseTimer.reset();\n\t\t// Synchronize fixtures, check for out of range bodies.\n\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t// If a body was not in an island then it did not move.\n\t\t\tif ((b.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Update fixtures (for broad-phase).\n\t\t\tb.synchronizeFixtures();\n\t\t}\n\n\t\t// Look for new contacts.\n\t\tm_contactManager.findNewContacts();\n\t\tm_profile.broadphase.record(broadphaseTimer.getMilliseconds());\n\t}\n\n\tprivate final Island toiIsland = new Island();\n\tprivate final TOIInput toiInput = new TOIInput();\n\tprivate final TOIOutput toiOutput = new TOIOutput();\n\tprivate final TimeStep subStep = new TimeStep();\n\tprivate final Body[] tempBodies = new Body[2];\n\tprivate final Sweep backup1 = new Sweep();\n\tprivate final Sweep backup2 = new Sweep();\n\n\tprivate void solveTOI (final TimeStep step) {\n\n\t\tfinal Island island = toiIsland;\n\t\tisland.init(2 * Settings.maxTOIContacts, Settings.maxTOIContacts, 0, m_contactManager.m_contactListener);\n\t\tif (m_stepComplete) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\tb.m_sweep.alpha0 = 0.0f;\n\t\t\t}\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Invalidate TOI\n\t\t\t\tc.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\tc.m_toiCount = 0;\n\t\t\t\tc.m_toi = 1.0f;\n\t\t\t}\n\t\t}\n\n\t\t// Find TOI events and solve them.\n\t\tfor (;;) {\n\t\t\t// Find the first TOI.\n\t\t\tContact minContact = null;\n\t\t\tfloat minAlpha = 1.0f;\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Is this contact disabled?\n\t\t\t\tif (c.isEnabled() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Prevent excessive sub-stepping.\n\t\t\t\tif (c.m_toiCount \> Settings.maxSubSteps) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat alpha = 1.0f;\n\t\t\t\tif ((c.m_flags & Contact.TOI_FLAG) != 0) {\n\t\t\t\t\t// This contact has a valid cached TOI.\n\t\t\t\t\talpha = c.m_toi;\n\t\t\t\t} else {\n\t\t\t\t\tFixture fA = c.getFixtureA();\n\t\t\t\t\tFixture fB = c.getFixtureB();\n\n\t\t\t\t\t// Is there a sensor?\n\t\t\t\t\tif (fA.isSensor() || fB.isSensor()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody bA = fA.getBody();\n\t\t\t\t\tBody bB = fB.getBody();\n\n\t\t\t\t\tBodyType typeA = bA.m_type;\n\t\t\t\t\tBodyType typeB = bB.m_type;\n\t\t\t\t\tassert (typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC);\n\n\t\t\t\t\tboolean activeA = bA.isAwake() && typeA != BodyType.STATIC;\n\t\t\t\t\tboolean activeB = bB.isAwake() && typeB != BodyType.STATIC;\n\n\t\t\t\t\t// Is at least one body active (awake and dynamic or kinematic)?\n\t\t\t\t\tif (activeA == false && activeB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;\n\t\t\t\t\tboolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;\n\n\t\t\t\t\t// Are these two non-bullet dynamic bodies?\n\t\t\t\t\tif (collideA == false && collideB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute the TOI for this contact.\n\t\t\t\t\t// Put the sweeps onto the same time interval.\n\t\t\t\t\tfloat alpha0 = bA.m_sweep.alpha0;\n\n\t\t\t\t\tif (bA.m_sweep.alpha0 \< bB.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bB.m_sweep.alpha0;\n\t\t\t\t\t\tbA.m_sweep.advance(alpha0);\n\t\t\t\t\t} else if (bB.m_sweep.alpha0 \< bA.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bA.m_sweep.alpha0;\n\t\t\t\t\t\tbB.m_sweep.advance(alpha0);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (alpha0 \< 1.0f);\n\n\t\t\t\t\tint indexA = c.getChildIndexA();\n\t\t\t\t\tint indexB = c.getChildIndexB();\n\n\t\t\t\t\t// Compute the time of impact in interval [0, minTOI]\n\t\t\t\t\tfinal TOIInput input = toiInput;\n\t\t\t\t\tinput.proxyA.set(fA.getShape(), indexA);\n\t\t\t\t\tinput.proxyB.set(fB.getShape(), indexB);\n\t\t\t\t\tinput.sweepA.set(bA.m_sweep);\n\t\t\t\t\tinput.sweepB.set(bB.m_sweep);\n\t\t\t\t\tinput.tMax = 1.0f;\n\n\t\t\t\t\tpool.getTimeOfImpact().timeOfImpact(toiOutput, input);\n\n\t\t\t\t\t// Beta is the fraction of the remaining portion of the .\n\t\t\t\t\tfloat beta = toiOutput.t;\n\t\t\t\t\tif (toiOutput.state == TOIOutputState.TOUCHING) {\n\t\t\t\t\t\talpha = MathUtils.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talpha = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.m_toi = alpha;\n\t\t\t\t\tc.m_flags |= Contact.TOI_FLAG;\n\t\t\t\t}\n\n\t\t\t\tif (alpha \< minAlpha) {\n\t\t\t\t\t// This is the minimum TOI found so far.\n\t\t\t\t\tminContact = c;\n\t\t\t\t\tminAlpha = alpha;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minContact == null || 1.0f - 10.0f * Settings.EPSILON \< minAlpha) {\n\t\t\t\t// No more TOI events. Done!\n\t\t\t\tm_stepComplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Advance the bodies to the TOI.\n\t\t\tFixture fA = minContact.getFixtureA();\n\t\t\tFixture fB = minContact.getFixtureB();\n\t\t\tBody bA = fA.getBody();\n\t\t\tBody bB = fB.getBody();\n\n\t\t\tbackup1.set(bA.m_sweep);\n\t\t\tbackup2.set(bB.m_sweep);\n\n\t\t\tbA.advance(minAlpha);\n\t\t\tbB.advance(minAlpha);\n\n\t\t\t// The TOI contact likely has some new contact points.\n\t\t\tminContact.update(m_contactManager.m_contactListener);\n\t\t\tminContact.m_flags &= ~Contact.TOI_FLAG;\n\t\t\t++minContact.m_toiCount;\n\n\t\t\t// Is the contact solid?\n\t\t\tif (minContact.isEnabled() == false || minContact.isTouching() == false) {\n\t\t\t\t// Restore the sweeps.\n\t\t\t\tminContact.setEnabled(false);\n\t\t\t\tbA.m_sweep.set(backup1);\n\t\t\t\tbB.m_sweep.set(backup2);\n\t\t\t\tbA.synchronizeTransform();\n\t\t\t\tbB.synchronizeTransform();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbA.setAwake(true);\n\t\t\tbB.setAwake(true);\n\n\t\t\t// Build the island\n\t\t\tisland.clear();\n\t\t\tisland.add(bA);\n\t\t\tisland.add(bB);\n\t\t\tisland.add(minContact);\n\n\t\t\tbA.m_flags |= Body.e_islandFlag;\n\t\t\tbB.m_flags |= Body.e_islandFlag;\n\t\t\tminContact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t// Get contacts on bodyA and bodyB.\n\t\t\ttempBodies[0] = bA;\n\t\t\ttempBodies[1] = bB;\n\t\t\tfor (int i = 0; i \< 2; ++i) {\n\t\t\t\tBody body = tempBodies[i];\n\t\t\t\tif (body.m_type == BodyType.DYNAMIC) {\n\t\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\t\tif (island.m_bodyCount == island.m_bodyCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (island.m_contactCount == island.m_contactCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t\t// Has this contact already been added to the island?\n\t\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only add static, kinematic, or bullet bodies.\n\t\t\t\t\t\tBody other = ce.other;\n\t\t\t\t\t\tif (other.m_type == BodyType.DYNAMIC && body.isBullet() == false && other.isBullet() == false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Skip sensors.\n\t\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Tentatively advance the body to the TOI.\n\t\t\t\t\t\tbackup1.set(other.m_sweep);\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\t\t\t\tother.advance(minAlpha);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the contact points\n\t\t\t\t\t\tcontact.update(m_contactManager.m_contactListener);\n\n\t\t\t\t\t\t// Was the contact disabled by the user?\n\t\t\t\t\t\tif (contact.isEnabled() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Are there contact points?\n\t\t\t\t\t\tif (contact.isTouching() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the contact to the island\n\t\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\t\t\t\t\t\tisland.add(contact);\n\n\t\t\t\t\t\t// Has the other body already been added to the island?\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the other body to the island.\n\t\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\n\t\t\t\t\t\tif (other.m_type != BodyType.STATIC) {\n\t\t\t\t\t\t\tother.setAwake(true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tisland.add(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsubStep.dt = (1.0f - minAlpha) * step.dt;\n\t\t\tsubStep.inv_dt = 1.0f / subStep.dt;\n\t\t\tsubStep.dtRatio = 1.0f;\n\t\t\tsubStep.positionIterations = 20;\n\t\t\tsubStep.velocityIterations = step.velocityIterations;\n\t\t\tsubStep.warmStarting = false;\n\t\t\tisland.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\n\n\t\t\t// Reset island flags and synchronize broad-phase proxies.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\tBody body = island.m_bodies[i];\n\t\t\t\tbody.m_flags &= ~Body.e_islandFlag;\n\n\t\t\t\tif (body.m_type != BodyType.DYNAMIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbody.synchronizeFixtures();\n\n\t\t\t\t// Invalidate all contact TOIs on this displaced body.\n\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tce.contact.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commit fixture proxy movements to the broad-phase so that new contacts are created.\n\t\t\t// Also, some contacts can be destroyed.\n\t\t\tm_contactManager.findNewContacts();\n\n\t\t\tif (m_subStepping) {\n\t\t\t\tm_stepComplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void drawJoint (Joint joint) {\n\t\tBody bodyA = joint.getBodyA();\n\t\tBody bodyB = joint.getBodyB();\n\t\tTransform xf1 = bodyA.getTransform();\n\t\tTransform xf2 = bodyB.getTransform();\n\t\tVec2 x1 = xf1.p;\n\t\tVec2 x2 = xf2.p;\n\t\tVec2 p1 = pool.popVec2();\n\t\tVec2 p2 = pool.popVec2();\n\t\tjoint.getAnchorA(p1);\n\t\tjoint.getAnchorB(p2);\n\n\t\tcolor.set(0.5f, 0.8f, 0.8f);\n\n\t\tswitch (joint.getType()) {\n\t\t// TODO djm write after writing joints\n\t\tcase DISTANCE:\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tbreak;\n\n\t\tcase PULLEY: {\n\t\t\tPulleyJoint pulley = (PulleyJoint)joint;\n\t\t\tVec2 s1 = pulley.getGroundAnchorA();\n\t\t\tVec2 s2 = pulley.getGroundAnchorB();\n\t\t\tm_debugDraw.drawSegment(s1, p1, color);\n\t\t\tm_debugDraw.drawSegment(s2, p2, color);\n\t\t\tm_debugDraw.drawSegment(s1, s2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CONSTANT_VOLUME:\n\t\tcase MOUSE:\n\t\t\t// don\'t draw this\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tm_debugDraw.drawSegment(x1, p1, color);\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tm_debugDraw.drawSegment(x2, p2, color);\n\t\t}\n\t\tpool.pushVec2(2);\n\t}\n\n\t// NOTE this corresponds to the liquid test, so the debugdraw can draw\n\t// the liquid particles correctly. They should be the same.\n\tprivate static Integer LIQUID_INT = new Integer(1234598372);\n\tprivate float liquidLength = .12f;\n\tprivate float averageLinearVel = -1;\n\tprivate final Vec2 liquidOffset = new Vec2();\n\tprivate final Vec2 circCenterMoved = new Vec2();\n\tprivate final Color3f liquidColor = new Color3f(.4f, .4f, 1f);\n\n\tprivate final Vec2 center = new Vec2();\n\tprivate final Vec2 axis = new Vec2();\n\tprivate final Vec2 v1 = new Vec2();\n\tprivate final Vec2 v2 = new Vec2();\n\tprivate final Vec2Array tlvertices = new Vec2Array();\n\n\tprivate void drawShape (Fixture fixture, Transform xf, Color3f color, boolean wireframe) {\n\t\tswitch (fixture.getType()) {\n\t\tcase CIRCLE: {\n\t\t\tCircleShape circle = (CircleShape)fixture.getShape();\n\n\t\t\t// Vec2 center = Mul(xf, circle.m_p);\n\t\t\tTransform.mulToOutUnsafe(xf, circle.m_p, center);\n\t\t\tfloat radius = circle.m_radius;\n\t\t\txf.q.getXAxis(axis);\n\n\t\t\tif (fixture.getUserData() != null && fixture.getUserData().equals(LIQUID_INT)) {\n\t\t\t\tBody b = fixture.getBody();\n\t\t\t\tliquidOffset.set(b.m_linearVelocity);\n\t\t\t\tfloat linVelLength = b.m_linearVelocity.length();\n\t\t\t\tif (averageLinearVel == -1) {\n\t\t\t\t\taverageLinearVel = linVelLength;\n\t\t\t\t} else {\n\t\t\t\t\taverageLinearVel = .98f * averageLinearVel + .02f * linVelLength;\n\t\t\t\t}\n\t\t\t\tliquidOffset.mulLocal(liquidLength / averageLinearVel / 2);\n\t\t\t\tcircCenterMoved.set(center).addLocal(liquidOffset);\n\t\t\t\tcenter.subLocal(liquidOffset);\n\t\t\t\tm_debugDraw.drawSegment(center, circCenterMoved, liquidColor);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawCircle(center, radius, axis, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidCircle(center, radius, axis, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase POLYGON: {\n\t\t\tPolygonShape poly = (PolygonShape)fixture.getShape();\n\t\t\tint vertexCount = poly.m_count;\n\t\t\tassert (vertexCount \<= Settings.maxPolygonVertices);\n\t\t\tVec2[] vertices = tlvertices.get(Settings.maxPolygonVertices);\n\n\t\t\tfor (int i = 0; i \< vertexCount; ++i) {\n\t\t\t\t// vertices[i] = Mul(xf, poly.m_vertices[i]);\n\t\t\t\tTransform.mulToOutUnsafe(xf, poly.m_vertices[i], vertices[i]);\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawPolygon(vertices, vertexCount, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidPolygon(vertices, vertexCount, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase EDGE: {\n\t\t\tEdgeShape edge = (EdgeShape)fixture.getShape();\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex1, v1);\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex2, v2);\n\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CHAIN: {\n\t\t\tChainShape chain = (ChainShape)fixture.getShape();\n\t\t\tint count = chain.m_count;\n\t\t\tVec2[] vertices = chain.m_vertices;\n\n\t\t\tTransform.mulToOutUnsafe(xf, vertices[0], v1);\n\t\t\tfor (int i = 1; i \< count; ++i) {\n\t\t\t\tTransform.mulToOutUnsafe(xf, vertices[i], v2);\n\t\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t\t\tm_debugDraw.drawCircle(v1, 0.05f, color);\n\t\t\t\tv1.set(v2);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void drawParticleSystem (ParticleSystem system) {\n\t\tboolean wireframe = (m_debugDraw.getFlags() & DebugDraw.e_wireframeDrawingBit) != 0;\n\t\tint particleCount = system.getParticleCount();\n\t\tif (particleCount != 0) {\n\t\t\tfloat particleRadius = system.getParticleRadius();\n\t\t\tVec2[] positionBuffer = system.getParticlePositionBuffer();\n\t\t\tParticleColor[] colorBuffer = null;\n\t\t\tif (system.m_colorBuffer.data != null) {\n\t\t\t\tcolorBuffer = system.getParticleColorBuffer();\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawParticlesWireframe(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawParticles(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Create a particle whose properties have been defined. No reference to the definition is retained. A simulation step must\n\t * occur before it\'s possible to interact with a newly created particle. For example, DestroyParticleInShape() will not destroy\n\t * a particle until Step() has been called.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @return the index of the particle. */\n\tpublic int createParticle (ParticleDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint p = m_particleSystem.createParticle(def);\n\t\treturn p;\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param index */\n\tpublic void destroyParticle (int index) {\n\t\tdestroyParticle(index, false);\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param Index of the particle to destroy.\n\t * @param Whether to call the destruction listener just before the particle is destroyed. */\n\tpublic void destroyParticle (int index, boolean callDestructionListener) {\n\t\tm_particleSystem.destroyParticle(index, callDestructionListener);\n\t}\n\n\t/** Destroy particles inside a shape without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks. For more information see DestroyParticleInShape(Shape&, Transform&,bool).\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf) {\n\t\treturn destroyParticlesInShape(shape, xf, false);\n\t}\n\n\t/** Destroy particles inside a shape. This function is locked during callbacks. In addition, this function immediately destroys\n\t * particles in the shape in contrast to DestroyParticle() which defers the destruction until the next simulation step.\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @param Whether to call the world b2DestructionListener for each particle destroyed.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn m_particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);\n\t}\n\n\t/** Create a particle group whose properties have been defined. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks. */\n\tpublic ParticleGroup createParticleGroup (ParticleGroupDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\tParticleGroup g = m_particleSystem.createParticleGroup(def);\n\t\treturn g;\n\t}\n\n\t/** Join two particle groups.\n\t * \n\t * @param the first group. Expands to encompass the second group.\n\t * @param the second group. It is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void joinParticleGroups (ParticleGroup groupA, ParticleGroup groupB) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.joinParticleGroups(groupA, groupB);\n\t}\n\n\t/** Destroy particles in a group. This function is locked during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @param Whether to call the world b2DestructionListener for each particle is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.destroyParticlesInGroup(group, callDestructionListener);\n\t}\n\n\t/** Destroy particles in a group without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group) {\n\t\tdestroyParticlesInGroup(group, false);\n\t}\n\n\t/** Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get the next group in the world\n\t * list. A NULL group indicates the end of the list.\n\t * \n\t * @return the head of the world particle group list. */\n\tpublic ParticleGroup[] getParticleGroupList () {\n\t\treturn m_particleSystem.getParticleGroupList();\n\t}\n\n\t/** Get the number of particle groups.\n\t * \n\t * @return */\n\tpublic int getParticleGroupCount () {\n\t\treturn m_particleSystem.getParticleGroupCount();\n\t}\n\n\t/** Get the number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleCount () {\n\t\treturn m_particleSystem.getParticleCount();\n\t}\n\n\t/** Get the maximum number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleMaxCount () {\n\t\treturn m_particleSystem.getParticleMaxCount();\n\t}\n\n\t/** Set the maximum number of particles.\n\t * \n\t * @param count */\n\tpublic void setParticleMaxCount (int count) {\n\t\tm_particleSystem.setParticleMaxCount(count);\n\t}\n\n\t/** Change the particle density.\n\t * \n\t * @param density */\n\tpublic void setParticleDensity (float density) {\n\t\tm_particleSystem.setParticleDensity(density);\n\t}\n\n\t/** Get the particle density.\n\t * \n\t * @return */\n\tpublic float getParticleDensity () {\n\t\treturn m_particleSystem.getParticleDensity();\n\t}\n\n\t/** Change the particle gravity scale. Adjusts the effect of the global gravity vector on particles. Default value is 1.0f.\n\t * \n\t * @param gravityScale */\n\tpublic void setParticleGravityScale (float gravityScale) {\n\t\tm_particleSystem.setParticleGravityScale(gravityScale);\n\n\t}\n\n\t/** Get the particle gravity scale.\n\t * \n\t * @return */\n\tpublic float getParticleGravityScale () {\n\t\treturn m_particleSystem.getParticleGravityScale();\n\t}\n\n\t/** Damping is used to reduce the velocity of particles. The damping parameter can be larger than 1.0f but the damping effect\n\t * becomes sensitive to the time step when the damping parameter is large.\n\t * \n\t * @param damping */\n\tpublic void setParticleDamping (float damping) {\n\t\tm_particleSystem.setParticleDamping(damping);\n\t}\n\n\t/** Get damping for particles\n\t * \n\t * @return */\n\tpublic float getParticleDamping () {\n\t\treturn m_particleSystem.getParticleDamping();\n\t}\n\n\t/** Change the particle radius. You should set this only once, on world start. If you change the radius during execution,\n\t * existing particles may explode, shrink, or behave unexpectedly.\n\t * \n\t * @param radius */\n\tpublic void setParticleRadius (float radius) {\n\t\tm_particleSystem.setParticleRadius(radius);\n\t}\n\n\t/** Get the particle radius.\n\t * \n\t * @return */\n\tpublic float getParticleRadius () {\n\t\treturn m_particleSystem.getParticleRadius();\n\t}\n\n\t/** Get the particle data. @return the pointer to the head of the particle data.\n\t * \n\t * @return */\n\tpublic int[] getParticleFlagsBuffer () {\n\t\treturn m_particleSystem.getParticleFlagsBuffer();\n\t}\n\n\tpublic Vec2[] getParticlePositionBuffer () {\n\t\treturn m_particleSystem.getParticlePositionBuffer();\n\t}\n\n\tpublic Vec2[] getParticleVelocityBuffer () {\n\t\treturn m_particleSystem.getParticleVelocityBuffer();\n\t}\n\n\tpublic ParticleColor[] getParticleColorBuffer () {\n\t\treturn m_particleSystem.getParticleColorBuffer();\n\t}\n\n\tpublic ParticleGroup[] getParticleGroupBuffer () {\n\t\treturn m_particleSystem.getParticleGroupBuffer();\n\t}\n\n\tpublic Object[] getParticleUserDataBuffer () {\n\t\treturn m_particleSystem.getParticleUserDataBuffer();\n\t}\n\n\t/** Set a buffer for particle data.\n\t * \n\t * @param buffer is a pointer to a block of memory.\n\t * @param size is the number of values in the block. */\n\tpublic void setParticleFlagsBuffer (int[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleFlagsBuffer(buffer, capacity);\n\t}\n\n\tpublic void setParticlePositionBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticlePositionBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleVelocityBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleVelocityBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleColorBuffer (ParticleColor[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleColorBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleUserDataBuffer (Object[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleUserDataBuffer(buffer, capacity);\n\t}\n\n\t/** Get contacts between particles\n\t * \n\t * @return */\n\tpublic ParticleContact[] getParticleContacts () {\n\t\treturn m_particleSystem.m_contactBuffer;\n\t}\n\n\tpublic int getParticleContactCount () {\n\t\treturn m_particleSystem.m_contactCount;\n\t}\n\n\t/** Get contacts between particles and bodies\n\t * \n\t * @return */\n\tpublic ParticleBodyContact[] getParticleBodyContacts () {\n\t\treturn m_particleSystem.m_bodyContactBuffer;\n\t}\n\n\tpublic int getParticleBodyContactCount () {\n\t\treturn m_particleSystem.m_bodyContactCount;\n\t}\n\n\t/** Compute the kinetic energy that can be lost by damping force\n\t * \n\t * @return */\n\tpublic float computeParticleCollisionEnergy () {\n\t\treturn m_particleSystem.computeParticleCollisionEnergy();\n\t}\n}\n\nclass WorldQueryWrapper implements TreeCallback {\n\tpublic boolean treeCallback (int nodeId) {\n\t\tFixtureProxy proxy = (FixtureProxy)broadPhase.getUserData(nodeId);\n\t\treturn callback.reportFixture(proxy.fixture);\n\t}\n\n\tBroadPhase broadPhase;\n\tQueryCallback callback;\n};\n\nclass WorldRayCastWrapper implements TreeRayCastCallback {\n\n\t// djm pooling\n\tprivate final RayCastOutput output = new RayCastOutput();\n\tprivate final Vec2 temp = new Vec2();\n\tprivate final Vec2 point = new Vec2();\n\n\tpublic float raycastCallback (RayCastInput input, int nodeId) {\n\t\tObject userData = broadPhase.getUserData(nodeId);\n\t\tFixtureProxy proxy = (FixtureProxy)userData;\n\t\tFixture fixture = proxy.fixture;\n\t\tint index = proxy.childIndex;\n\t\tboolean hit = fixture.raycast(output, input, index);\n\n\t\tif (hit) {\n\t\t\tfloat fraction = output.fraction;\n\t\t\t// Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;\n\t\t\ttemp.set(input.p2).mulLocal(fraction);\n\t\t\tpoint.set(input.p1).mulLocal(1 - fraction).addLocal(temp);\n\t\t\treturn callback.reportFixture(fixture, point, output.normal, fraction);\n\t\t}\n\n\t\treturn input.maxFraction;\n\t}\n\n\tBroadPhase broadPhase;\n\tRayCastCallback callback;\n};\n")
  2257 of 2379 processed succesfully!
  2258 of 2379 processed succesfully!
  2267 of 2379 processed succesfully!
  2271 of 2379 processed succesfully!
  2277 of 2379 processed succesfully!
  2278 of 2379 processed succesfully!
  2279 of 2379 processed succesfully!
  2280 of 2379 processed succesfully!
  2283 of 2379 processed succesfully!
  2286 of 2379 processed succesfully!
  2289 of 2379 processed succesfully!
  2292 of 2379 processed succesfully!
  2293 of 2379 processed succesfully!
  2298 of 2379 processed succesfully!
  2299 of 2379 processed succesfully!
  2301 of 2379 processed succesfully!
  2302 of 2379 processed succesfully!
  2304 of 2379 processed succesfully!
  2306 of 2379 processed succesfully!
  2307 of 2379 processed succesfully!
  2312 of 2379 processed succesfully!
  2316 of 2379 processed succesfully!
  2324 of 2379 processed succesfully!
  2325 of 2379 processed succesfully!
  2329 of 2379 processed succesfully!
  2340 of 2379 processed succesfully!
  2355 of 2379 processed succesfully!
44
[Project Analyzer] project: libgdx
Processing libgdx...
  468 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/math/collision/OrientedBoundingBox.java|
ParseError(|unknown:///|(3189,1,<97,32>,<97,33>))
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/collision/RayCastOutput.java|
Ambiguity(|unknown:///|(0,1979,<1,0>,<45,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.collision;\n\nimport org.jbox2d.common.Vec2;\n\n// updated to rev 100\n/** Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from b2RayCastInput. */\npublic class RayCastOutput {\n\tpublic final Vec2 normal;\n\tpublic float fraction;\n\n\tpublic RayCastOutput () {\n\t\tnormal = new Vec2();\n\t\tfraction = 0;\n\t}\n\n\tpublic void set (final RayCastOutput rco) {\n\t\tnormal.set(rco.normal);\n\t\tfraction = rco.fraction;\n\t}\n};\n")
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/dynamics/World.java|
Ambiguity(|unknown:///|(0,56587,<1,0>,<1895,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.dynamics;\n\nimport org.jbox2d.callbacks.ContactFilter;\nimport org.jbox2d.callbacks.ContactListener;\nimport org.jbox2d.callbacks.DebugDraw;\nimport org.jbox2d.callbacks.DestructionListener;\nimport org.jbox2d.callbacks.ParticleDestructionListener;\nimport org.jbox2d.callbacks.ParticleQueryCallback;\nimport org.jbox2d.callbacks.ParticleRaycastCallback;\nimport org.jbox2d.callbacks.QueryCallback;\nimport org.jbox2d.callbacks.RayCastCallback;\nimport org.jbox2d.callbacks.TreeCallback;\nimport org.jbox2d.callbacks.TreeRayCastCallback;\nimport org.jbox2d.collision.AABB;\nimport org.jbox2d.collision.RayCastInput;\nimport org.jbox2d.collision.RayCastOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIInput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutputState;\nimport org.jbox2d.collision.broadphase.BroadPhase;\nimport org.jbox2d.collision.broadphase.BroadPhaseStrategy;\nimport org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer;\nimport org.jbox2d.collision.broadphase.DynamicTree;\nimport org.jbox2d.collision.shapes.ChainShape;\nimport org.jbox2d.collision.shapes.CircleShape;\nimport org.jbox2d.collision.shapes.EdgeShape;\nimport org.jbox2d.collision.shapes.PolygonShape;\nimport org.jbox2d.collision.shapes.Shape;\nimport org.jbox2d.collision.shapes.ShapeType;\nimport org.jbox2d.common.Color3f;\nimport org.jbox2d.common.MathUtils;\nimport org.jbox2d.common.Settings;\nimport org.jbox2d.common.Sweep;\nimport org.jbox2d.common.Timer;\nimport org.jbox2d.common.Transform;\nimport org.jbox2d.common.Vec2;\nimport org.jbox2d.dynamics.contacts.Contact;\nimport org.jbox2d.dynamics.contacts.ContactEdge;\nimport org.jbox2d.dynamics.contacts.ContactRegister;\nimport org.jbox2d.dynamics.joints.Joint;\nimport org.jbox2d.dynamics.joints.JointDef;\nimport org.jbox2d.dynamics.joints.JointEdge;\nimport org.jbox2d.dynamics.joints.PulleyJoint;\nimport org.jbox2d.particle.ParticleBodyContact;\nimport org.jbox2d.particle.ParticleColor;\nimport org.jbox2d.particle.ParticleContact;\nimport org.jbox2d.particle.ParticleDef;\nimport org.jbox2d.particle.ParticleGroup;\nimport org.jbox2d.particle.ParticleGroupDef;\nimport org.jbox2d.particle.ParticleSystem;\nimport org.jbox2d.pooling.IDynamicStack;\nimport org.jbox2d.pooling.IWorldPool;\nimport org.jbox2d.pooling.arrays.Vec2Array;\nimport org.jbox2d.pooling.normal.DefaultWorldPool;\n\n/** The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n * memory management facilities.\n * \n * @author Daniel Murphy */\npublic class World {\n\tpublic static final int WORLD_POOL_SIZE = 100;\n\tpublic static final int WORLD_POOL_CONTAINER_SIZE = 10;\n\n\tpublic static final int NEW_FIXTURE = 0x0001;\n\tpublic static final int LOCKED = 0x0002;\n\tpublic static final int CLEAR_FORCES = 0x0004;\n\n\t// statistics gathering\n\tpublic int activeContacts = 0;\n\tpublic int contactPoolCount = 0;\n\n\tprotected int m_flags;\n\n\tprotected ContactManager m_contactManager;\n\n\tprivate Body m_bodyList;\n\tprivate Joint m_jointList;\n\n\tprivate int m_bodyCount;\n\tprivate int m_jointCount;\n\n\tprivate final Vec2 m_gravity = new Vec2();\n\tprivate boolean m_allowSleep;\n\n\t// private Body m_groundBody;\n\n\tprivate DestructionListener m_destructionListener;\n\tprivate ParticleDestructionListener m_particleDestructionListener;\n\tprivate DebugDraw m_debugDraw;\n\n\tprivate final IWorldPool pool;\n\n\t/** This is used to compute the time step ratio to support a variable time step. */\n\tprivate float m_inv_dt0;\n\n\t// these are for debugging the solver\n\tprivate boolean m_warmStarting;\n\tprivate boolean m_continuousPhysics;\n\tprivate boolean m_subStepping;\n\n\tprivate boolean m_stepComplete;\n\n\tprivate Profile m_profile;\n\n\tprivate ParticleSystem m_particleSystem;\n\n\tprivate ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity, IWorldPool pool) {\n\t\tthis(gravity, pool, new DynamicTree());\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhaseStrategy strategy) {\n\t\tthis(gravity, pool, new DefaultBroadPhaseBuffer(strategy));\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhase broadPhase) {\n\t\tthis.pool = pool;\n\t\tm_destructionListener = null;\n\t\tm_debugDraw = null;\n\n\t\tm_bodyList = null;\n\t\tm_jointList = null;\n\n\t\tm_bodyCount = 0;\n\t\tm_jointCount = 0;\n\n\t\tm_warmStarting = true;\n\t\tm_continuousPhysics = true;\n\t\tm_subStepping = false;\n\t\tm_stepComplete = true;\n\n\t\tm_allowSleep = true;\n\t\tm_gravity.set(gravity);\n\n\t\tm_flags = CLEAR_FORCES;\n\n\t\tm_inv_dt0 = 0f;\n\n\t\tm_contactManager = new ContactManager(this, broadPhase);\n\t\tm_profile = new Profile();\n\n\t\tm_particleSystem = new ParticleSystem(this);\n\n\t\tinitializeRegisters();\n\t}\n\n\tpublic void setAllowSleep (boolean flag) {\n\t\tif (flag == m_allowSleep) {\n\t\t\treturn;\n\t\t}\n\n\t\tm_allowSleep = flag;\n\t\tif (m_allowSleep == false) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.setAwake(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSubStepping (boolean subStepping) {\n\t\tthis.m_subStepping = subStepping;\n\t}\n\n\tpublic boolean isSubStepping () {\n\t\treturn m_subStepping;\n\t}\n\n\tpublic boolean isAllowSleep () {\n\t\treturn m_allowSleep;\n\t}\n\n\tprivate void addType (IDynamicStack\<Contact\> creator, ShapeType type1, ShapeType type2) {\n\t\tContactRegister register = new ContactRegister();\n\t\tregister.creator = creator;\n\t\tregister.primary = true;\n\t\tcontactStacks[type1.ordinal()][type2.ordinal()] = register;\n\n\t\tif (type1 != type2) {\n\t\t\tContactRegister register2 = new ContactRegister();\n\t\t\tregister2.creator = creator;\n\t\t\tregister2.primary = false;\n\t\t\tcontactStacks[type2.ordinal()][type1.ordinal()] = register2;\n\t\t}\n\t}\n\n\tprivate void initializeRegisters () {\n\t\taddType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);\n\t\taddType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);\n\t\taddType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);\n\t\taddType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);\n\t\taddType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);\n\t}\n\n\tpublic DestructionListener getDestructionListener () {\n\t\treturn m_destructionListener;\n\t}\n\n\tpublic ParticleDestructionListener getParticleDestructionListener () {\n\t\treturn m_particleDestructionListener;\n\t}\n\n\tpublic void setParticleDestructionListener (ParticleDestructionListener listener) {\n\t\tm_particleDestructionListener = listener;\n\t}\n\n\tpublic Contact popContact (Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {\n\t\tfinal ShapeType type1 = fixtureA.getType();\n\t\tfinal ShapeType type2 = fixtureB.getType();\n\n\t\tfinal ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];\n\t\tif (reg != null) {\n\t\t\tif (reg.primary) {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureA, indexA, fixtureB, indexB);\n\t\t\t\treturn c;\n\t\t\t} else {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureB, indexB, fixtureA, indexA);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void pushContact (Contact contact) {\n\t\tFixture fixtureA = contact.getFixtureA();\n\t\tFixture fixtureB = contact.getFixtureB();\n\n\t\tif (contact.m_manifold.pointCount \> 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {\n\t\t\tfixtureA.getBody().setAwake(true);\n\t\t\tfixtureB.getBody().setAwake(true);\n\t\t}\n\n\t\tShapeType type1 = fixtureA.getType();\n\t\tShapeType type2 = fixtureB.getType();\n\n\t\tIDynamicStack\<Contact\> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;\n\t\tcreator.push(contact);\n\t}\n\n\tpublic IWorldPool getPool () {\n\t\treturn pool;\n\t}\n\n\t/** Register a destruction listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setDestructionListener (DestructionListener listener) {\n\t\tm_destructionListener = listener;\n\t}\n\n\t/** Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n\t * (_defaultFilter). The listener is owned by you and must remain in scope.\n\t * \n\t * @param filter */\n\tpublic void setContactFilter (ContactFilter filter) {\n\t\tm_contactManager.m_contactFilter = filter;\n\t}\n\n\t/** Register a contact event listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setContactListener (ContactListener listener) {\n\t\tm_contactManager.m_contactListener = listener;\n\t}\n\n\t/** Register a routine for debug drawing. The debug draw functions are called inside with World.DrawDebugData method. The debug\n\t * draw object is owned by you and must remain in scope.\n\t * \n\t * @param debugDraw */\n\tpublic void setDebugDraw (DebugDraw debugDraw) {\n\t\tm_debugDraw = debugDraw;\n\t}\n\n\t/** create a rigid body given a definition. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Body createBody (BodyDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\t// TODO djm pooling\n\t\tBody b = new Body(def, this);\n\n\t\t// add to world doubly linked list\n\t\tb.m_prev = null;\n\t\tb.m_next = m_bodyList;\n\t\tif (m_bodyList != null) {\n\t\t\tm_bodyList.m_prev = b;\n\t\t}\n\t\tm_bodyList = b;\n\t\t++m_bodyCount;\n\n\t\treturn b;\n\t}\n\n\t/** destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n\t * callbacks.\n\t * \n\t * @warning This automatically deletes all associated shapes and joints.\n\t * @warning This function is locked during callbacks.\n\t * @param body */\n\tpublic void destroyBody (Body body) {\n\t\tassert (m_bodyCount \> 0);\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete the attached joints.\n\t\tJointEdge je = body.m_jointList;\n\t\twhile (je != null) {\n\t\t\tJointEdge je0 = je;\n\t\t\tje = je.next;\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(je0.joint);\n\t\t\t}\n\n\t\t\tdestroyJoint(je0.joint);\n\n\t\t\tbody.m_jointList = je;\n\t\t}\n\t\tbody.m_jointList = null;\n\n\t\t// Delete the attached contacts.\n\t\tContactEdge ce = body.m_contactList;\n\t\twhile (ce != null) {\n\t\t\tContactEdge ce0 = ce;\n\t\t\tce = ce.next;\n\t\t\tm_contactManager.destroy(ce0.contact);\n\t\t}\n\t\tbody.m_contactList = null;\n\n\t\tFixture f = body.m_fixtureList;\n\t\twhile (f != null) {\n\t\t\tFixture f0 = f;\n\t\t\tf = f.m_next;\n\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(f0);\n\t\t\t}\n\n\t\t\tf0.destroyProxies(m_contactManager.m_broadPhase);\n\t\t\tf0.destroy();\n\t\t\t// TODO djm recycle fixtures (here or in that destroy method)\n\t\t\tbody.m_fixtureList = f;\n\t\t\tbody.m_fixtureCount -= 1;\n\t\t}\n\t\tbody.m_fixtureList = null;\n\t\tbody.m_fixtureCount = 0;\n\n\t\t// Remove world body list.\n\t\tif (body.m_prev != null) {\n\t\t\tbody.m_prev.m_next = body.m_next;\n\t\t}\n\n\t\tif (body.m_next != null) {\n\t\t\tbody.m_next.m_prev = body.m_prev;\n\t\t}\n\n\t\tif (body == m_bodyList) {\n\t\t\tm_bodyList = body.m_next;\n\t\t}\n\n\t\t--m_bodyCount;\n\t\t// TODO djm recycle body\n\t}\n\n\t/** create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected\n\t * bodies to cease colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Joint createJoint (JointDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJoint j = Joint.create(this, def);\n\n\t\t// Connect to the world list.\n\t\tj.m_prev = null;\n\t\tj.m_next = m_jointList;\n\t\tif (m_jointList != null) {\n\t\t\tm_jointList.m_prev = j;\n\t\t}\n\t\tm_jointList = j;\n\t\t++m_jointCount;\n\n\t\t// Connect to the bodies\' doubly linked lists.\n\t\tj.m_edgeA.joint = j;\n\t\tj.m_edgeA.other = j.getBodyB();\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = j.getBodyA().m_jointList;\n\t\tif (j.getBodyA().m_jointList != null) {\n\t\t\tj.getBodyA().m_jointList.prev = j.m_edgeA;\n\t\t}\n\t\tj.getBodyA().m_jointList = j.m_edgeA;\n\n\t\tj.m_edgeB.joint = j;\n\t\tj.m_edgeB.other = j.getBodyA();\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = j.getBodyB().m_jointList;\n\t\tif (j.getBodyB().m_jointList != null) {\n\t\t\tj.getBodyB().m_jointList.prev = j.m_edgeB;\n\t\t}\n\t\tj.getBodyB().m_jointList = j.m_edgeB;\n\n\t\tBody bodyA = def.bodyA;\n\t\tBody bodyB = def.bodyB;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (def.collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\n\t\t// Note: creating a joint doesn\'t wake the bodies.\n\n\t\treturn j;\n\t}\n\n\t/** destroy a joint. This may cause the connected bodies to begin colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param joint */\n\tpublic void destroyJoint (Joint j) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\tboolean collideConnected = j.getCollideConnected();\n\n\t\t// Remove from the doubly linked list.\n\t\tif (j.m_prev != null) {\n\t\t\tj.m_prev.m_next = j.m_next;\n\t\t}\n\n\t\tif (j.m_next != null) {\n\t\t\tj.m_next.m_prev = j.m_prev;\n\t\t}\n\n\t\tif (j == m_jointList) {\n\t\t\tm_jointList = j.m_next;\n\t\t}\n\n\t\t// Disconnect from island graph.\n\t\tBody bodyA = j.getBodyA();\n\t\tBody bodyB = j.getBodyB();\n\n\t\t// Wake up connected bodies.\n\t\tbodyA.setAwake(true);\n\t\tbodyB.setAwake(true);\n\n\t\t// Remove from body 1.\n\t\tif (j.m_edgeA.prev != null) {\n\t\t\tj.m_edgeA.prev.next = j.m_edgeA.next;\n\t\t}\n\n\t\tif (j.m_edgeA.next != null) {\n\t\t\tj.m_edgeA.next.prev = j.m_edgeA.prev;\n\t\t}\n\n\t\tif (j.m_edgeA == bodyA.m_jointList) {\n\t\t\tbodyA.m_jointList = j.m_edgeA.next;\n\t\t}\n\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = null;\n\n\t\t// Remove from body 2\n\t\tif (j.m_edgeB.prev != null) {\n\t\t\tj.m_edgeB.prev.next = j.m_edgeB.next;\n\t\t}\n\n\t\tif (j.m_edgeB.next != null) {\n\t\t\tj.m_edgeB.next.prev = j.m_edgeB.prev;\n\t\t}\n\n\t\tif (j.m_edgeB == bodyB.m_jointList) {\n\t\t\tbodyB.m_jointList = j.m_edgeB.next;\n\t\t}\n\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = null;\n\n\t\tJoint.destroy(j);\n\n\t\tassert (m_jointCount \> 0);\n\t\t--m_jointCount;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\t}\n\n\t// djm pooling\n\tprivate final TimeStep step = new TimeStep();\n\tprivate final Timer stepTimer = new Timer();\n\tprivate final Timer tempTimer = new Timer();\n\n\t/** Take a time step. This performs collision detection, integration, and constraint solution.\n\t * \n\t * @param timeStep the amount of time to simulate, this should not vary.\n\t * @param velocityIterations for the velocity constraint solver.\n\t * @param positionIterations for the position constraint solver. */\n\tpublic void step (float dt, int velocityIterations, int positionIterations) {\n\t\tstepTimer.reset();\n\t\ttempTimer.reset();\n\t\t// log.debug(\"Starting step\");\n\t\t// If new fixtures were added, we need to find the new contacts.\n\t\tif ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\n\t\t\t// log.debug(\"There\'s a new fixture, lets look for new contacts\");\n\t\t\tm_contactManager.findNewContacts();\n\t\t\tm_flags &= ~NEW_FIXTURE;\n\t\t}\n\n\t\tm_flags |= LOCKED;\n\n\t\tstep.dt = dt;\n\t\tstep.velocityIterations = velocityIterations;\n\t\tstep.positionIterations = positionIterations;\n\t\tif (dt \> 0.0f) {\n\t\t\tstep.inv_dt = 1.0f / dt;\n\t\t} else {\n\t\t\tstep.inv_dt = 0.0f;\n\t\t}\n\n\t\tstep.dtRatio = m_inv_dt0 * dt;\n\n\t\tstep.warmStarting = m_warmStarting;\n\t\tm_profile.stepInit.record(tempTimer.getMilliseconds());\n\n\t\t// Update contacts. This is where some contacts are destroyed.\n\t\ttempTimer.reset();\n\t\tm_contactManager.collide();\n\t\tm_profile.collide.record(tempTimer.getMilliseconds());\n\n\t\t// Integrate velocities, solve velocity constraints, and integrate positions.\n\t\tif (m_stepComplete && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tm_particleSystem.solve(step); // Particle Simulation\n\t\t\tm_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\n\t\t\ttempTimer.reset();\n\t\t\tsolve(step);\n\t\t\tm_profile.solve.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\t// Handle TOI events.\n\t\tif (m_continuousPhysics && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tsolveTOI(step);\n\t\t\tm_profile.solveTOI.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\tif (step.dt \> 0.0f) {\n\t\t\tm_inv_dt0 = step.inv_dt;\n\t\t}\n\n\t\tif ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\n\t\t\tclearForces();\n\t\t}\n\n\t\tm_flags &= ~LOCKED;\n\t\t// log.debug(\"ending step\");\n\n\t\tm_profile.step.record(stepTimer.getMilliseconds());\n\t}\n\n\t/** Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless\n\t * you are performing sub-steps. By default, forces will be automatically cleared, so you don\'t need to call this function.\n\t * \n\t * @see setAutoClearForces */\n\tpublic void clearForces () {\n\t\tfor (Body body = m_bodyList; body != null; body = body.getNext()) {\n\t\t\tbody.m_force.setZero();\n\t\t\tbody.m_torque = 0.0f;\n\t\t}\n\t}\n\n\tprivate final Color3f color = new Color3f();\n\tprivate final Transform xf = new Transform();\n\tprivate final Vec2 cA = new Vec2();\n\tprivate final Vec2 cB = new Vec2();\n\tprivate final Vec2Array avs = new Vec2Array();\n\n\t/** Call this to draw shapes and other debug draw data. */\n\tpublic void drawDebugData () {\n\t\tif (m_debugDraw == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint flags = m_debugDraw.getFlags();\n\t\tboolean wireframe = (flags & DebugDraw.e_wireframeDrawingBit) != 0;\n\n\t\tif ((flags & DebugDraw.e_shapeBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.STATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.9f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.KINEMATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.9f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.isAwake() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.5f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolor.set(0.9f, 0.7f, 0.7f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawParticleSystem(m_particleSystem);\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_jointBit) != 0) {\n\t\t\tfor (Joint j = m_jointList; j != null; j = j.getNext()) {\n\t\t\t\tdrawJoint(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_pairBit) != 0) {\n\t\t\tcolor.set(0.3f, 0.9f, 0.9f);\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.getNext()) {\n\t\t\t\tFixture fixtureA = c.getFixtureA();\n\t\t\t\tFixture fixtureB = c.getFixtureB();\n\t\t\t\tfixtureA.getAABB(c.getChildIndexA()).getCenterToOut(cA);\n\t\t\t\tfixtureB.getAABB(c.getChildIndexB()).getCenterToOut(cB);\n\t\t\t\tm_debugDraw.drawSegment(cA, cB, color);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_aabbBit) != 0) {\n\t\t\tcolor.set(0.9f, 0.3f, 0.9f);\n\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tfor (int i = 0; i \< f.m_proxyCount; ++i) {\n\t\t\t\t\t\tFixtureProxy proxy = f.m_proxies[i];\n\t\t\t\t\t\tAABB aabb = m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);\n\t\t\t\t\t\tif (aabb != null) {\n\t\t\t\t\t\t\tVec2[] vs = avs.get(4);\n\t\t\t\t\t\t\tvs[0].set(aabb.lowerBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[1].set(aabb.upperBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[2].set(aabb.upperBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tvs[3].set(aabb.lowerBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tm_debugDraw.drawPolygon(vs, 4, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_centerOfMassBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\txf.p.set(b.getWorldCenter());\n\t\t\t\tm_debugDraw.drawTransform(xf);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_dynamicTreeBit) != 0) {\n\t\t\tm_contactManager.m_broadPhase.drawTree(m_debugDraw);\n\t\t}\n\n\t\tm_debugDraw.flush();\n\t}\n\n\tprivate final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();\n\n\t/** Query the world for all fixtures that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t}\n\n\t/** Query the world for all fixtures and particles that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\t/** Query the world for all particles that potentially overlap the provided AABB.\n\t * \n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (ParticleQueryCallback particleCallback, AABB aabb) {\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\tprivate final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();\n\tprivate final RayCastInput input = new RayCastInput();\n\n\t/** Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t}\n\n\t/** Ray-cast the world for all fixtures and particles in the path of the ray. Your callback controls whether you get the\n\t * closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Ray-cast the world for all particles in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points.\n\t * \n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Get the world body list. With the returned body, use Body.getNext to get the next body in the world list. A null body\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world body list. */\n\tpublic Body getBodyList () {\n\t\treturn m_bodyList;\n\t}\n\n\t/** Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in the world list. A null joint\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world joint list. */\n\tpublic Joint getJointList () {\n\t\treturn m_jointList;\n\t}\n\n\t/** Get the world contact list. With the returned contact, use Contact.getNext to get the next contact in the world list. A\n\t * null contact indicates the end of the list.\n\t * \n\t * @return the head of the world contact list.\n\t * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener to avoid missing contacts. */\n\tpublic Contact getContactList () {\n\t\treturn m_contactManager.m_contactList;\n\t}\n\n\tpublic boolean isSleepingAllowed () {\n\t\treturn m_allowSleep;\n\t}\n\n\tpublic void setSleepingAllowed (boolean sleepingAllowed) {\n\t\tm_allowSleep = sleepingAllowed;\n\t}\n\n\t/** Enable/disable warm starting. For testing.\n\t * \n\t * @param flag */\n\tpublic void setWarmStarting (boolean flag) {\n\t\tm_warmStarting = flag;\n\t}\n\n\tpublic boolean isWarmStarting () {\n\t\treturn m_warmStarting;\n\t}\n\n\t/** Enable/disable continuous physics. For testing.\n\t * \n\t * @param flag */\n\tpublic void setContinuousPhysics (boolean flag) {\n\t\tm_continuousPhysics = flag;\n\t}\n\n\tpublic boolean isContinuousPhysics () {\n\t\treturn m_continuousPhysics;\n\t}\n\n\t/** Get the number of broad-phase proxies.\n\t * \n\t * @return */\n\tpublic int getProxyCount () {\n\t\treturn m_contactManager.m_broadPhase.getProxyCount();\n\t}\n\n\t/** Get the number of bodies.\n\t * \n\t * @return */\n\tpublic int getBodyCount () {\n\t\treturn m_bodyCount;\n\t}\n\n\t/** Get the number of joints.\n\t * \n\t * @return */\n\tpublic int getJointCount () {\n\t\treturn m_jointCount;\n\t}\n\n\t/** Get the number of contacts (each may have 0 or more contact points).\n\t * \n\t * @return */\n\tpublic int getContactCount () {\n\t\treturn m_contactManager.m_contactCount;\n\t}\n\n\t/** Gets the height of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeHeight () {\n\t\treturn m_contactManager.m_broadPhase.getTreeHeight();\n\t}\n\n\t/** Gets the balance of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeBalance () {\n\t\treturn m_contactManager.m_broadPhase.getTreeBalance();\n\t}\n\n\t/** Gets the quality of the dynamic tree\n\t * \n\t * @return */\n\tpublic float getTreeQuality () {\n\t\treturn m_contactManager.m_broadPhase.getTreeQuality();\n\t}\n\n\t/** Change the global gravity vector.\n\t * \n\t * @param gravity */\n\tpublic void setGravity (Vec2 gravity) {\n\t\tm_gravity.set(gravity);\n\t}\n\n\t/** Get the global gravity vector.\n\t * \n\t * @return */\n\tpublic Vec2 getGravity () {\n\t\treturn m_gravity;\n\t}\n\n\t/** Is the world locked (in the middle of a time step).\n\t * \n\t * @return */\n\tpublic boolean isLocked () {\n\t\treturn (m_flags & LOCKED) == LOCKED;\n\t}\n\n\t/** Set flag to control automatic clearing of forces after each time step.\n\t * \n\t * @param flag */\n\tpublic void setAutoClearForces (boolean flag) {\n\t\tif (flag) {\n\t\t\tm_flags |= CLEAR_FORCES;\n\t\t} else {\n\t\t\tm_flags &= ~CLEAR_FORCES;\n\t\t}\n\t}\n\n\t/** Get the flag that controls automatic clearing of forces after each time step.\n\t * \n\t * @return */\n\tpublic boolean getAutoClearForces () {\n\t\treturn (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\n\t}\n\n\t/** Get the contact manager for testing purposes\n\t * \n\t * @return */\n\tpublic ContactManager getContactManager () {\n\t\treturn m_contactManager;\n\t}\n\n\tpublic Profile getProfile () {\n\t\treturn m_profile;\n\t}\n\n\tprivate final Island island = new Island();\n\tprivate Body[] stack = new Body[10]; // TODO djm find a good initial stack number;\n\tprivate final Timer broadphaseTimer = new Timer();\n\n\tprivate void solve (TimeStep step) {\n\t\tm_profile.solveInit.startAccum();\n\t\tm_profile.solveVelocity.startAccum();\n\t\tm_profile.solvePosition.startAccum();\n\n\t\t// update previous transforms\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_xf0.set(b.m_xf);\n\t\t}\n\n\t\t// Size the island for the worst case.\n\t\tisland.init(m_bodyCount, m_contactManager.m_contactCount, m_jointCount, m_contactManager.m_contactListener);\n\n\t\t// Clear all the island flags.\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t}\n\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\tc.m_flags &= ~Contact.ISLAND_FLAG;\n\t\t}\n\t\tfor (Joint j = m_jointList; j != null; j = j.m_next) {\n\t\t\tj.m_islandFlag = false;\n\t\t}\n\n\t\t// Build and simulate all awake islands.\n\t\tint stackSize = m_bodyCount;\n\t\tif (stack.length \< stackSize) {\n\t\t\tstack = new Body[stackSize];\n\t\t}\n\t\tfor (Body seed = m_bodyList; seed != null; seed = seed.m_next) {\n\t\t\tif ((seed.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (seed.isAwake() == false || seed.isActive() == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The seed can be dynamic or kinematic.\n\t\t\tif (seed.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Reset island and stack.\n\t\t\tisland.clear();\n\t\t\tint stackCount = 0;\n\t\t\tstack[stackCount++] = seed;\n\t\t\tseed.m_flags |= Body.e_islandFlag;\n\n\t\t\t// Perform a depth first search (DFS) on the constraint graph.\n\t\t\twhile (stackCount \> 0) {\n\t\t\t\t// Grab the next body off the stack and add it to the island.\n\t\t\t\tBody b = stack[--stackCount];\n\t\t\t\tassert (b.isActive() == true);\n\t\t\t\tisland.add(b);\n\n\t\t\t\t// Make sure the body is awake.\n\t\t\t\tb.setAwake(true);\n\n\t\t\t\t// To keep islands as small as possible, we don\'t\n\t\t\t\t// propagate islands across static bodies.\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Search all contacts connected to this body.\n\t\t\t\tfor (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t// Has this contact already been added to an island?\n\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Is this contact solid and touching?\n\t\t\t\t\tif (contact.isEnabled() == false || contact.isTouching() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip sensors.\n\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(contact);\n\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t\t\tBody other = ce.other;\n\n\t\t\t\t\t// Was the other body already added to this island?\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\n\t\t\t\t// Search all joints connect to this body.\n\t\t\t\tfor (JointEdge je = b.m_jointList; je != null; je = je.next) {\n\t\t\t\t\tif (je.joint.m_islandFlag == true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody other = je.other;\n\n\t\t\t\t\t// Don\'t simulate joints connected to inactive bodies.\n\t\t\t\t\tif (other.isActive() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(je.joint);\n\t\t\t\t\tje.joint.m_islandFlag = true;\n\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tisland.solve(m_profile, step, m_gravity, m_allowSleep);\n\n\t\t\t// Post solve cleanup.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\t// Allow static bodies to participate in other islands.\n\t\t\t\tBody b = island.m_bodies[i];\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm_profile.solveInit.endAccum();\n\t\tm_profile.solveVelocity.endAccum();\n\t\tm_profile.solvePosition.endAccum();\n\n\t\tbroadphaseTimer.reset();\n\t\t// Synchronize fixtures, check for out of range bodies.\n\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t// If a body was not in an island then it did not move.\n\t\t\tif ((b.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Update fixtures (for broad-phase).\n\t\t\tb.synchronizeFixtures();\n\t\t}\n\n\t\t// Look for new contacts.\n\t\tm_contactManager.findNewContacts();\n\t\tm_profile.broadphase.record(broadphaseTimer.getMilliseconds());\n\t}\n\n\tprivate final Island toiIsland = new Island();\n\tprivate final TOIInput toiInput = new TOIInput();\n\tprivate final TOIOutput toiOutput = new TOIOutput();\n\tprivate final TimeStep subStep = new TimeStep();\n\tprivate final Body[] tempBodies = new Body[2];\n\tprivate final Sweep backup1 = new Sweep();\n\tprivate final Sweep backup2 = new Sweep();\n\n\tprivate void solveTOI (final TimeStep step) {\n\n\t\tfinal Island island = toiIsland;\n\t\tisland.init(2 * Settings.maxTOIContacts, Settings.maxTOIContacts, 0, m_contactManager.m_contactListener);\n\t\tif (m_stepComplete) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\tb.m_sweep.alpha0 = 0.0f;\n\t\t\t}\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Invalidate TOI\n\t\t\t\tc.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\tc.m_toiCount = 0;\n\t\t\t\tc.m_toi = 1.0f;\n\t\t\t}\n\t\t}\n\n\t\t// Find TOI events and solve them.\n\t\tfor (;;) {\n\t\t\t// Find the first TOI.\n\t\t\tContact minContact = null;\n\t\t\tfloat minAlpha = 1.0f;\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Is this contact disabled?\n\t\t\t\tif (c.isEnabled() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Prevent excessive sub-stepping.\n\t\t\t\tif (c.m_toiCount \> Settings.maxSubSteps) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat alpha = 1.0f;\n\t\t\t\tif ((c.m_flags & Contact.TOI_FLAG) != 0) {\n\t\t\t\t\t// This contact has a valid cached TOI.\n\t\t\t\t\talpha = c.m_toi;\n\t\t\t\t} else {\n\t\t\t\t\tFixture fA = c.getFixtureA();\n\t\t\t\t\tFixture fB = c.getFixtureB();\n\n\t\t\t\t\t// Is there a sensor?\n\t\t\t\t\tif (fA.isSensor() || fB.isSensor()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody bA = fA.getBody();\n\t\t\t\t\tBody bB = fB.getBody();\n\n\t\t\t\t\tBodyType typeA = bA.m_type;\n\t\t\t\t\tBodyType typeB = bB.m_type;\n\t\t\t\t\tassert (typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC);\n\n\t\t\t\t\tboolean activeA = bA.isAwake() && typeA != BodyType.STATIC;\n\t\t\t\t\tboolean activeB = bB.isAwake() && typeB != BodyType.STATIC;\n\n\t\t\t\t\t// Is at least one body active (awake and dynamic or kinematic)?\n\t\t\t\t\tif (activeA == false && activeB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;\n\t\t\t\t\tboolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;\n\n\t\t\t\t\t// Are these two non-bullet dynamic bodies?\n\t\t\t\t\tif (collideA == false && collideB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute the TOI for this contact.\n\t\t\t\t\t// Put the sweeps onto the same time interval.\n\t\t\t\t\tfloat alpha0 = bA.m_sweep.alpha0;\n\n\t\t\t\t\tif (bA.m_sweep.alpha0 \< bB.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bB.m_sweep.alpha0;\n\t\t\t\t\t\tbA.m_sweep.advance(alpha0);\n\t\t\t\t\t} else if (bB.m_sweep.alpha0 \< bA.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bA.m_sweep.alpha0;\n\t\t\t\t\t\tbB.m_sweep.advance(alpha0);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (alpha0 \< 1.0f);\n\n\t\t\t\t\tint indexA = c.getChildIndexA();\n\t\t\t\t\tint indexB = c.getChildIndexB();\n\n\t\t\t\t\t// Compute the time of impact in interval [0, minTOI]\n\t\t\t\t\tfinal TOIInput input = toiInput;\n\t\t\t\t\tinput.proxyA.set(fA.getShape(), indexA);\n\t\t\t\t\tinput.proxyB.set(fB.getShape(), indexB);\n\t\t\t\t\tinput.sweepA.set(bA.m_sweep);\n\t\t\t\t\tinput.sweepB.set(bB.m_sweep);\n\t\t\t\t\tinput.tMax = 1.0f;\n\n\t\t\t\t\tpool.getTimeOfImpact().timeOfImpact(toiOutput, input);\n\n\t\t\t\t\t// Beta is the fraction of the remaining portion of the .\n\t\t\t\t\tfloat beta = toiOutput.t;\n\t\t\t\t\tif (toiOutput.state == TOIOutputState.TOUCHING) {\n\t\t\t\t\t\talpha = MathUtils.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talpha = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.m_toi = alpha;\n\t\t\t\t\tc.m_flags |= Contact.TOI_FLAG;\n\t\t\t\t}\n\n\t\t\t\tif (alpha \< minAlpha) {\n\t\t\t\t\t// This is the minimum TOI found so far.\n\t\t\t\t\tminContact = c;\n\t\t\t\t\tminAlpha = alpha;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minContact == null || 1.0f - 10.0f * Settings.EPSILON \< minAlpha) {\n\t\t\t\t// No more TOI events. Done!\n\t\t\t\tm_stepComplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Advance the bodies to the TOI.\n\t\t\tFixture fA = minContact.getFixtureA();\n\t\t\tFixture fB = minContact.getFixtureB();\n\t\t\tBody bA = fA.getBody();\n\t\t\tBody bB = fB.getBody();\n\n\t\t\tbackup1.set(bA.m_sweep);\n\t\t\tbackup2.set(bB.m_sweep);\n\n\t\t\tbA.advance(minAlpha);\n\t\t\tbB.advance(minAlpha);\n\n\t\t\t// The TOI contact likely has some new contact points.\n\t\t\tminContact.update(m_contactManager.m_contactListener);\n\t\t\tminContact.m_flags &= ~Contact.TOI_FLAG;\n\t\t\t++minContact.m_toiCount;\n\n\t\t\t// Is the contact solid?\n\t\t\tif (minContact.isEnabled() == false || minContact.isTouching() == false) {\n\t\t\t\t// Restore the sweeps.\n\t\t\t\tminContact.setEnabled(false);\n\t\t\t\tbA.m_sweep.set(backup1);\n\t\t\t\tbB.m_sweep.set(backup2);\n\t\t\t\tbA.synchronizeTransform();\n\t\t\t\tbB.synchronizeTransform();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbA.setAwake(true);\n\t\t\tbB.setAwake(true);\n\n\t\t\t// Build the island\n\t\t\tisland.clear();\n\t\t\tisland.add(bA);\n\t\t\tisland.add(bB);\n\t\t\tisland.add(minContact);\n\n\t\t\tbA.m_flags |= Body.e_islandFlag;\n\t\t\tbB.m_flags |= Body.e_islandFlag;\n\t\t\tminContact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t// Get contacts on bodyA and bodyB.\n\t\t\ttempBodies[0] = bA;\n\t\t\ttempBodies[1] = bB;\n\t\t\tfor (int i = 0; i \< 2; ++i) {\n\t\t\t\tBody body = tempBodies[i];\n\t\t\t\tif (body.m_type == BodyType.DYNAMIC) {\n\t\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\t\tif (island.m_bodyCount == island.m_bodyCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (island.m_contactCount == island.m_contactCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t\t// Has this contact already been added to the island?\n\t\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only add static, kinematic, or bullet bodies.\n\t\t\t\t\t\tBody other = ce.other;\n\t\t\t\t\t\tif (other.m_type == BodyType.DYNAMIC && body.isBullet() == false && other.isBullet() == false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Skip sensors.\n\t\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Tentatively advance the body to the TOI.\n\t\t\t\t\t\tbackup1.set(other.m_sweep);\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\t\t\t\tother.advance(minAlpha);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the contact points\n\t\t\t\t\t\tcontact.update(m_contactManager.m_contactListener);\n\n\t\t\t\t\t\t// Was the contact disabled by the user?\n\t\t\t\t\t\tif (contact.isEnabled() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Are there contact points?\n\t\t\t\t\t\tif (contact.isTouching() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the contact to the island\n\t\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\t\t\t\t\t\tisland.add(contact);\n\n\t\t\t\t\t\t// Has the other body already been added to the island?\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the other body to the island.\n\t\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\n\t\t\t\t\t\tif (other.m_type != BodyType.STATIC) {\n\t\t\t\t\t\t\tother.setAwake(true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tisland.add(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsubStep.dt = (1.0f - minAlpha) * step.dt;\n\t\t\tsubStep.inv_dt = 1.0f / subStep.dt;\n\t\t\tsubStep.dtRatio = 1.0f;\n\t\t\tsubStep.positionIterations = 20;\n\t\t\tsubStep.velocityIterations = step.velocityIterations;\n\t\t\tsubStep.warmStarting = false;\n\t\t\tisland.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\n\n\t\t\t// Reset island flags and synchronize broad-phase proxies.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\tBody body = island.m_bodies[i];\n\t\t\t\tbody.m_flags &= ~Body.e_islandFlag;\n\n\t\t\t\tif (body.m_type != BodyType.DYNAMIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbody.synchronizeFixtures();\n\n\t\t\t\t// Invalidate all contact TOIs on this displaced body.\n\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tce.contact.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commit fixture proxy movements to the broad-phase so that new contacts are created.\n\t\t\t// Also, some contacts can be destroyed.\n\t\t\tm_contactManager.findNewContacts();\n\n\t\t\tif (m_subStepping) {\n\t\t\t\tm_stepComplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void drawJoint (Joint joint) {\n\t\tBody bodyA = joint.getBodyA();\n\t\tBody bodyB = joint.getBodyB();\n\t\tTransform xf1 = bodyA.getTransform();\n\t\tTransform xf2 = bodyB.getTransform();\n\t\tVec2 x1 = xf1.p;\n\t\tVec2 x2 = xf2.p;\n\t\tVec2 p1 = pool.popVec2();\n\t\tVec2 p2 = pool.popVec2();\n\t\tjoint.getAnchorA(p1);\n\t\tjoint.getAnchorB(p2);\n\n\t\tcolor.set(0.5f, 0.8f, 0.8f);\n\n\t\tswitch (joint.getType()) {\n\t\t// TODO djm write after writing joints\n\t\tcase DISTANCE:\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tbreak;\n\n\t\tcase PULLEY: {\n\t\t\tPulleyJoint pulley = (PulleyJoint)joint;\n\t\t\tVec2 s1 = pulley.getGroundAnchorA();\n\t\t\tVec2 s2 = pulley.getGroundAnchorB();\n\t\t\tm_debugDraw.drawSegment(s1, p1, color);\n\t\t\tm_debugDraw.drawSegment(s2, p2, color);\n\t\t\tm_debugDraw.drawSegment(s1, s2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CONSTANT_VOLUME:\n\t\tcase MOUSE:\n\t\t\t// don\'t draw this\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tm_debugDraw.drawSegment(x1, p1, color);\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tm_debugDraw.drawSegment(x2, p2, color);\n\t\t}\n\t\tpool.pushVec2(2);\n\t}\n\n\t// NOTE this corresponds to the liquid test, so the debugdraw can draw\n\t// the liquid particles correctly. They should be the same.\n\tprivate static Integer LIQUID_INT = new Integer(1234598372);\n\tprivate float liquidLength = .12f;\n\tprivate float averageLinearVel = -1;\n\tprivate final Vec2 liquidOffset = new Vec2();\n\tprivate final Vec2 circCenterMoved = new Vec2();\n\tprivate final Color3f liquidColor = new Color3f(.4f, .4f, 1f);\n\n\tprivate final Vec2 center = new Vec2();\n\tprivate final Vec2 axis = new Vec2();\n\tprivate final Vec2 v1 = new Vec2();\n\tprivate final Vec2 v2 = new Vec2();\n\tprivate final Vec2Array tlvertices = new Vec2Array();\n\n\tprivate void drawShape (Fixture fixture, Transform xf, Color3f color, boolean wireframe) {\n\t\tswitch (fixture.getType()) {\n\t\tcase CIRCLE: {\n\t\t\tCircleShape circle = (CircleShape)fixture.getShape();\n\n\t\t\t// Vec2 center = Mul(xf, circle.m_p);\n\t\t\tTransform.mulToOutUnsafe(xf, circle.m_p, center);\n\t\t\tfloat radius = circle.m_radius;\n\t\t\txf.q.getXAxis(axis);\n\n\t\t\tif (fixture.getUserData() != null && fixture.getUserData().equals(LIQUID_INT)) {\n\t\t\t\tBody b = fixture.getBody();\n\t\t\t\tliquidOffset.set(b.m_linearVelocity);\n\t\t\t\tfloat linVelLength = b.m_linearVelocity.length();\n\t\t\t\tif (averageLinearVel == -1) {\n\t\t\t\t\taverageLinearVel = linVelLength;\n\t\t\t\t} else {\n\t\t\t\t\taverageLinearVel = .98f * averageLinearVel + .02f * linVelLength;\n\t\t\t\t}\n\t\t\t\tliquidOffset.mulLocal(liquidLength / averageLinearVel / 2);\n\t\t\t\tcircCenterMoved.set(center).addLocal(liquidOffset);\n\t\t\t\tcenter.subLocal(liquidOffset);\n\t\t\t\tm_debugDraw.drawSegment(center, circCenterMoved, liquidColor);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawCircle(center, radius, axis, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidCircle(center, radius, axis, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase POLYGON: {\n\t\t\tPolygonShape poly = (PolygonShape)fixture.getShape();\n\t\t\tint vertexCount = poly.m_count;\n\t\t\tassert (vertexCount \<= Settings.maxPolygonVertices);\n\t\t\tVec2[] vertices = tlvertices.get(Settings.maxPolygonVertices);\n\n\t\t\tfor (int i = 0; i \< vertexCount; ++i) {\n\t\t\t\t// vertices[i] = Mul(xf, poly.m_vertices[i]);\n\t\t\t\tTransform.mulToOutUnsafe(xf, poly.m_vertices[i], vertices[i]);\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawPolygon(vertices, vertexCount, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidPolygon(vertices, vertexCount, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase EDGE: {\n\t\t\tEdgeShape edge = (EdgeShape)fixture.getShape();\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex1, v1);\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex2, v2);\n\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CHAIN: {\n\t\t\tChainShape chain = (ChainShape)fixture.getShape();\n\t\t\tint count = chain.m_count;\n\t\t\tVec2[] vertices = chain.m_vertices;\n\n\t\t\tTransform.mulToOutUnsafe(xf, vertices[0], v1);\n\t\t\tfor (int i = 1; i \< count; ++i) {\n\t\t\t\tTransform.mulToOutUnsafe(xf, vertices[i], v2);\n\t\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t\t\tm_debugDraw.drawCircle(v1, 0.05f, color);\n\t\t\t\tv1.set(v2);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void drawParticleSystem (ParticleSystem system) {\n\t\tboolean wireframe = (m_debugDraw.getFlags() & DebugDraw.e_wireframeDrawingBit) != 0;\n\t\tint particleCount = system.getParticleCount();\n\t\tif (particleCount != 0) {\n\t\t\tfloat particleRadius = system.getParticleRadius();\n\t\t\tVec2[] positionBuffer = system.getParticlePositionBuffer();\n\t\t\tParticleColor[] colorBuffer = null;\n\t\t\tif (system.m_colorBuffer.data != null) {\n\t\t\t\tcolorBuffer = system.getParticleColorBuffer();\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawParticlesWireframe(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawParticles(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Create a particle whose properties have been defined. No reference to the definition is retained. A simulation step must\n\t * occur before it\'s possible to interact with a newly created particle. For example, DestroyParticleInShape() will not destroy\n\t * a particle until Step() has been called.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @return the index of the particle. */\n\tpublic int createParticle (ParticleDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint p = m_particleSystem.createParticle(def);\n\t\treturn p;\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param index */\n\tpublic void destroyParticle (int index) {\n\t\tdestroyParticle(index, false);\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param Index of the particle to destroy.\n\t * @param Whether to call the destruction listener just before the particle is destroyed. */\n\tpublic void destroyParticle (int index, boolean callDestructionListener) {\n\t\tm_particleSystem.destroyParticle(index, callDestructionListener);\n\t}\n\n\t/** Destroy particles inside a shape without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks. For more information see DestroyParticleInShape(Shape&, Transform&,bool).\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf) {\n\t\treturn destroyParticlesInShape(shape, xf, false);\n\t}\n\n\t/** Destroy particles inside a shape. This function is locked during callbacks. In addition, this function immediately destroys\n\t * particles in the shape in contrast to DestroyParticle() which defers the destruction until the next simulation step.\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @param Whether to call the world b2DestructionListener for each particle destroyed.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn m_particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);\n\t}\n\n\t/** Create a particle group whose properties have been defined. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks. */\n\tpublic ParticleGroup createParticleGroup (ParticleGroupDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\tParticleGroup g = m_particleSystem.createParticleGroup(def);\n\t\treturn g;\n\t}\n\n\t/** Join two particle groups.\n\t * \n\t * @param the first group. Expands to encompass the second group.\n\t * @param the second group. It is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void joinParticleGroups (ParticleGroup groupA, ParticleGroup groupB) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.joinParticleGroups(groupA, groupB);\n\t}\n\n\t/** Destroy particles in a group. This function is locked during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @param Whether to call the world b2DestructionListener for each particle is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.destroyParticlesInGroup(group, callDestructionListener);\n\t}\n\n\t/** Destroy particles in a group without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group) {\n\t\tdestroyParticlesInGroup(group, false);\n\t}\n\n\t/** Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get the next group in the world\n\t * list. A NULL group indicates the end of the list.\n\t * \n\t * @return the head of the world particle group list. */\n\tpublic ParticleGroup[] getParticleGroupList () {\n\t\treturn m_particleSystem.getParticleGroupList();\n\t}\n\n\t/** Get the number of particle groups.\n\t * \n\t * @return */\n\tpublic int getParticleGroupCount () {\n\t\treturn m_particleSystem.getParticleGroupCount();\n\t}\n\n\t/** Get the number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleCount () {\n\t\treturn m_particleSystem.getParticleCount();\n\t}\n\n\t/** Get the maximum number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleMaxCount () {\n\t\treturn m_particleSystem.getParticleMaxCount();\n\t}\n\n\t/** Set the maximum number of particles.\n\t * \n\t * @param count */\n\tpublic void setParticleMaxCount (int count) {\n\t\tm_particleSystem.setParticleMaxCount(count);\n\t}\n\n\t/** Change the particle density.\n\t * \n\t * @param density */\n\tpublic void setParticleDensity (float density) {\n\t\tm_particleSystem.setParticleDensity(density);\n\t}\n\n\t/** Get the particle density.\n\t * \n\t * @return */\n\tpublic float getParticleDensity () {\n\t\treturn m_particleSystem.getParticleDensity();\n\t}\n\n\t/** Change the particle gravity scale. Adjusts the effect of the global gravity vector on particles. Default value is 1.0f.\n\t * \n\t * @param gravityScale */\n\tpublic void setParticleGravityScale (float gravityScale) {\n\t\tm_particleSystem.setParticleGravityScale(gravityScale);\n\n\t}\n\n\t/** Get the particle gravity scale.\n\t * \n\t * @return */\n\tpublic float getParticleGravityScale () {\n\t\treturn m_particleSystem.getParticleGravityScale();\n\t}\n\n\t/** Damping is used to reduce the velocity of particles. The damping parameter can be larger than 1.0f but the damping effect\n\t * becomes sensitive to the time step when the damping parameter is large.\n\t * \n\t * @param damping */\n\tpublic void setParticleDamping (float damping) {\n\t\tm_particleSystem.setParticleDamping(damping);\n\t}\n\n\t/** Get damping for particles\n\t * \n\t * @return */\n\tpublic float getParticleDamping () {\n\t\treturn m_particleSystem.getParticleDamping();\n\t}\n\n\t/** Change the particle radius. You should set this only once, on world start. If you change the radius during execution,\n\t * existing particles may explode, shrink, or behave unexpectedly.\n\t * \n\t * @param radius */\n\tpublic void setParticleRadius (float radius) {\n\t\tm_particleSystem.setParticleRadius(radius);\n\t}\n\n\t/** Get the particle radius.\n\t * \n\t * @return */\n\tpublic float getParticleRadius () {\n\t\treturn m_particleSystem.getParticleRadius();\n\t}\n\n\t/** Get the particle data. @return the pointer to the head of the particle data.\n\t * \n\t * @return */\n\tpublic int[] getParticleFlagsBuffer () {\n\t\treturn m_particleSystem.getParticleFlagsBuffer();\n\t}\n\n\tpublic Vec2[] getParticlePositionBuffer () {\n\t\treturn m_particleSystem.getParticlePositionBuffer();\n\t}\n\n\tpublic Vec2[] getParticleVelocityBuffer () {\n\t\treturn m_particleSystem.getParticleVelocityBuffer();\n\t}\n\n\tpublic ParticleColor[] getParticleColorBuffer () {\n\t\treturn m_particleSystem.getParticleColorBuffer();\n\t}\n\n\tpublic ParticleGroup[] getParticleGroupBuffer () {\n\t\treturn m_particleSystem.getParticleGroupBuffer();\n\t}\n\n\tpublic Object[] getParticleUserDataBuffer () {\n\t\treturn m_particleSystem.getParticleUserDataBuffer();\n\t}\n\n\t/** Set a buffer for particle data.\n\t * \n\t * @param buffer is a pointer to a block of memory.\n\t * @param size is the number of values in the block. */\n\tpublic void setParticleFlagsBuffer (int[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleFlagsBuffer(buffer, capacity);\n\t}\n\n\tpublic void setParticlePositionBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticlePositionBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleVelocityBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleVelocityBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleColorBuffer (ParticleColor[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleColorBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleUserDataBuffer (Object[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleUserDataBuffer(buffer, capacity);\n\t}\n\n\t/** Get contacts between particles\n\t * \n\t * @return */\n\tpublic ParticleContact[] getParticleContacts () {\n\t\treturn m_particleSystem.m_contactBuffer;\n\t}\n\n\tpublic int getParticleContactCount () {\n\t\treturn m_particleSystem.m_contactCount;\n\t}\n\n\t/** Get contacts between particles and bodies\n\t * \n\t * @return */\n\tpublic ParticleBodyContact[] getParticleBodyContacts () {\n\t\treturn m_particleSystem.m_bodyContactBuffer;\n\t}\n\n\tpublic int getParticleBodyContactCount () {\n\t\treturn m_particleSystem.m_bodyContactCount;\n\t}\n\n\t/** Compute the kinetic energy that can be lost by damping force\n\t * \n\t * @return */\n\tpublic float computeParticleCollisionEnergy () {\n\t\treturn m_particleSystem.computeParticleCollisionEnergy();\n\t}\n}\n\nclass WorldQueryWrapper implements TreeCallback {\n\tpublic boolean treeCallback (int nodeId) {\n\t\tFixtureProxy proxy = (FixtureProxy)broadPhase.getUserData(nodeId);\n\t\treturn callback.reportFixture(proxy.fixture);\n\t}\n\n\tBroadPhase broadPhase;\n\tQueryCallback callback;\n};\n\nclass WorldRayCastWrapper implements TreeRayCastCallback {\n\n\t// djm pooling\n\tprivate final RayCastOutput output = new RayCastOutput();\n\tprivate final Vec2 temp = new Vec2();\n\tprivate final Vec2 point = new Vec2();\n\n\tpublic float raycastCallback (RayCastInput input, int nodeId) {\n\t\tObject userData = broadPhase.getUserData(nodeId);\n\t\tFixtureProxy proxy = (FixtureProxy)userData;\n\t\tFixture fixture = proxy.fixture;\n\t\tint index = proxy.childIndex;\n\t\tboolean hit = fixture.raycast(output, input, index);\n\n\t\tif (hit) {\n\t\t\tfloat fraction = output.fraction;\n\t\t\t// Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;\n\t\t\ttemp.set(input.p2).mulLocal(fraction);\n\t\t\tpoint.set(input.p1).mulLocal(1 - fraction).addLocal(temp);\n\t\t\treturn callback.reportFixture(fixture, point, output.normal, fraction);\n\t\t}\n\n\t\treturn input.maxFraction;\n\t}\n\n\tBroadPhase broadPhase;\n\tRayCastCallback callback;\n};\n")
1
[Project Analyzer] project: libgdx
Processing libgdx...
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/math/collision/OrientedBoundingBox.java|
ParseError(|unknown:///|(3189,1,<97,32>,<97,33>))
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/collision/RayCastOutput.java|
Ambiguity(|unknown:///|(0,1979,<1,0>,<45,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.collision;\n\nimport org.jbox2d.common.Vec2;\n\n// updated to rev 100\n/** Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from b2RayCastInput. */\npublic class RayCastOutput {\n\tpublic final Vec2 normal;\n\tpublic float fraction;\n\n\tpublic RayCastOutput () {\n\t\tnormal = new Vec2();\n\t\tfraction = 0;\n\t}\n\n\tpublic void set (final RayCastOutput rco) {\n\t\tnormal.set(rco.normal);\n\t\tfraction = rco.fraction;\n\t}\n};\n")
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/dynamics/World.java|
Ambiguity(|unknown:///|(0,56587,<1,0>,<1895,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.dynamics;\n\nimport org.jbox2d.callbacks.ContactFilter;\nimport org.jbox2d.callbacks.ContactListener;\nimport org.jbox2d.callbacks.DebugDraw;\nimport org.jbox2d.callbacks.DestructionListener;\nimport org.jbox2d.callbacks.ParticleDestructionListener;\nimport org.jbox2d.callbacks.ParticleQueryCallback;\nimport org.jbox2d.callbacks.ParticleRaycastCallback;\nimport org.jbox2d.callbacks.QueryCallback;\nimport org.jbox2d.callbacks.RayCastCallback;\nimport org.jbox2d.callbacks.TreeCallback;\nimport org.jbox2d.callbacks.TreeRayCastCallback;\nimport org.jbox2d.collision.AABB;\nimport org.jbox2d.collision.RayCastInput;\nimport org.jbox2d.collision.RayCastOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIInput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutputState;\nimport org.jbox2d.collision.broadphase.BroadPhase;\nimport org.jbox2d.collision.broadphase.BroadPhaseStrategy;\nimport org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer;\nimport org.jbox2d.collision.broadphase.DynamicTree;\nimport org.jbox2d.collision.shapes.ChainShape;\nimport org.jbox2d.collision.shapes.CircleShape;\nimport org.jbox2d.collision.shapes.EdgeShape;\nimport org.jbox2d.collision.shapes.PolygonShape;\nimport org.jbox2d.collision.shapes.Shape;\nimport org.jbox2d.collision.shapes.ShapeType;\nimport org.jbox2d.common.Color3f;\nimport org.jbox2d.common.MathUtils;\nimport org.jbox2d.common.Settings;\nimport org.jbox2d.common.Sweep;\nimport org.jbox2d.common.Timer;\nimport org.jbox2d.common.Transform;\nimport org.jbox2d.common.Vec2;\nimport org.jbox2d.dynamics.contacts.Contact;\nimport org.jbox2d.dynamics.contacts.ContactEdge;\nimport org.jbox2d.dynamics.contacts.ContactRegister;\nimport org.jbox2d.dynamics.joints.Joint;\nimport org.jbox2d.dynamics.joints.JointDef;\nimport org.jbox2d.dynamics.joints.JointEdge;\nimport org.jbox2d.dynamics.joints.PulleyJoint;\nimport org.jbox2d.particle.ParticleBodyContact;\nimport org.jbox2d.particle.ParticleColor;\nimport org.jbox2d.particle.ParticleContact;\nimport org.jbox2d.particle.ParticleDef;\nimport org.jbox2d.particle.ParticleGroup;\nimport org.jbox2d.particle.ParticleGroupDef;\nimport org.jbox2d.particle.ParticleSystem;\nimport org.jbox2d.pooling.IDynamicStack;\nimport org.jbox2d.pooling.IWorldPool;\nimport org.jbox2d.pooling.arrays.Vec2Array;\nimport org.jbox2d.pooling.normal.DefaultWorldPool;\n\n/** The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n * memory management facilities.\n * \n * @author Daniel Murphy */\npublic class World {\n\tpublic static final int WORLD_POOL_SIZE = 100;\n\tpublic static final int WORLD_POOL_CONTAINER_SIZE = 10;\n\n\tpublic static final int NEW_FIXTURE = 0x0001;\n\tpublic static final int LOCKED = 0x0002;\n\tpublic static final int CLEAR_FORCES = 0x0004;\n\n\t// statistics gathering\n\tpublic int activeContacts = 0;\n\tpublic int contactPoolCount = 0;\n\n\tprotected int m_flags;\n\n\tprotected ContactManager m_contactManager;\n\n\tprivate Body m_bodyList;\n\tprivate Joint m_jointList;\n\n\tprivate int m_bodyCount;\n\tprivate int m_jointCount;\n\n\tprivate final Vec2 m_gravity = new Vec2();\n\tprivate boolean m_allowSleep;\n\n\t// private Body m_groundBody;\n\n\tprivate DestructionListener m_destructionListener;\n\tprivate ParticleDestructionListener m_particleDestructionListener;\n\tprivate DebugDraw m_debugDraw;\n\n\tprivate final IWorldPool pool;\n\n\t/** This is used to compute the time step ratio to support a variable time step. */\n\tprivate float m_inv_dt0;\n\n\t// these are for debugging the solver\n\tprivate boolean m_warmStarting;\n\tprivate boolean m_continuousPhysics;\n\tprivate boolean m_subStepping;\n\n\tprivate boolean m_stepComplete;\n\n\tprivate Profile m_profile;\n\n\tprivate ParticleSystem m_particleSystem;\n\n\tprivate ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity, IWorldPool pool) {\n\t\tthis(gravity, pool, new DynamicTree());\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhaseStrategy strategy) {\n\t\tthis(gravity, pool, new DefaultBroadPhaseBuffer(strategy));\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhase broadPhase) {\n\t\tthis.pool = pool;\n\t\tm_destructionListener = null;\n\t\tm_debugDraw = null;\n\n\t\tm_bodyList = null;\n\t\tm_jointList = null;\n\n\t\tm_bodyCount = 0;\n\t\tm_jointCount = 0;\n\n\t\tm_warmStarting = true;\n\t\tm_continuousPhysics = true;\n\t\tm_subStepping = false;\n\t\tm_stepComplete = true;\n\n\t\tm_allowSleep = true;\n\t\tm_gravity.set(gravity);\n\n\t\tm_flags = CLEAR_FORCES;\n\n\t\tm_inv_dt0 = 0f;\n\n\t\tm_contactManager = new ContactManager(this, broadPhase);\n\t\tm_profile = new Profile();\n\n\t\tm_particleSystem = new ParticleSystem(this);\n\n\t\tinitializeRegisters();\n\t}\n\n\tpublic void setAllowSleep (boolean flag) {\n\t\tif (flag == m_allowSleep) {\n\t\t\treturn;\n\t\t}\n\n\t\tm_allowSleep = flag;\n\t\tif (m_allowSleep == false) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.setAwake(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSubStepping (boolean subStepping) {\n\t\tthis.m_subStepping = subStepping;\n\t}\n\n\tpublic boolean isSubStepping () {\n\t\treturn m_subStepping;\n\t}\n\n\tpublic boolean isAllowSleep () {\n\t\treturn m_allowSleep;\n\t}\n\n\tprivate void addType (IDynamicStack\<Contact\> creator, ShapeType type1, ShapeType type2) {\n\t\tContactRegister register = new ContactRegister();\n\t\tregister.creator = creator;\n\t\tregister.primary = true;\n\t\tcontactStacks[type1.ordinal()][type2.ordinal()] = register;\n\n\t\tif (type1 != type2) {\n\t\t\tContactRegister register2 = new ContactRegister();\n\t\t\tregister2.creator = creator;\n\t\t\tregister2.primary = false;\n\t\t\tcontactStacks[type2.ordinal()][type1.ordinal()] = register2;\n\t\t}\n\t}\n\n\tprivate void initializeRegisters () {\n\t\taddType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);\n\t\taddType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);\n\t\taddType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);\n\t\taddType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);\n\t\taddType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);\n\t}\n\n\tpublic DestructionListener getDestructionListener () {\n\t\treturn m_destructionListener;\n\t}\n\n\tpublic ParticleDestructionListener getParticleDestructionListener () {\n\t\treturn m_particleDestructionListener;\n\t}\n\n\tpublic void setParticleDestructionListener (ParticleDestructionListener listener) {\n\t\tm_particleDestructionListener = listener;\n\t}\n\n\tpublic Contact popContact (Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {\n\t\tfinal ShapeType type1 = fixtureA.getType();\n\t\tfinal ShapeType type2 = fixtureB.getType();\n\n\t\tfinal ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];\n\t\tif (reg != null) {\n\t\t\tif (reg.primary) {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureA, indexA, fixtureB, indexB);\n\t\t\t\treturn c;\n\t\t\t} else {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureB, indexB, fixtureA, indexA);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void pushContact (Contact contact) {\n\t\tFixture fixtureA = contact.getFixtureA();\n\t\tFixture fixtureB = contact.getFixtureB();\n\n\t\tif (contact.m_manifold.pointCount \> 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {\n\t\t\tfixtureA.getBody().setAwake(true);\n\t\t\tfixtureB.getBody().setAwake(true);\n\t\t}\n\n\t\tShapeType type1 = fixtureA.getType();\n\t\tShapeType type2 = fixtureB.getType();\n\n\t\tIDynamicStack\<Contact\> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;\n\t\tcreator.push(contact);\n\t}\n\n\tpublic IWorldPool getPool () {\n\t\treturn pool;\n\t}\n\n\t/** Register a destruction listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setDestructionListener (DestructionListener listener) {\n\t\tm_destructionListener = listener;\n\t}\n\n\t/** Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n\t * (_defaultFilter). The listener is owned by you and must remain in scope.\n\t * \n\t * @param filter */\n\tpublic void setContactFilter (ContactFilter filter) {\n\t\tm_contactManager.m_contactFilter = filter;\n\t}\n\n\t/** Register a contact event listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setContactListener (ContactListener listener) {\n\t\tm_contactManager.m_contactListener = listener;\n\t}\n\n\t/** Register a routine for debug drawing. The debug draw functions are called inside with World.DrawDebugData method. The debug\n\t * draw object is owned by you and must remain in scope.\n\t * \n\t * @param debugDraw */\n\tpublic void setDebugDraw (DebugDraw debugDraw) {\n\t\tm_debugDraw = debugDraw;\n\t}\n\n\t/** create a rigid body given a definition. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Body createBody (BodyDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\t// TODO djm pooling\n\t\tBody b = new Body(def, this);\n\n\t\t// add to world doubly linked list\n\t\tb.m_prev = null;\n\t\tb.m_next = m_bodyList;\n\t\tif (m_bodyList != null) {\n\t\t\tm_bodyList.m_prev = b;\n\t\t}\n\t\tm_bodyList = b;\n\t\t++m_bodyCount;\n\n\t\treturn b;\n\t}\n\n\t/** destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n\t * callbacks.\n\t * \n\t * @warning This automatically deletes all associated shapes and joints.\n\t * @warning This function is locked during callbacks.\n\t * @param body */\n\tpublic void destroyBody (Body body) {\n\t\tassert (m_bodyCount \> 0);\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete the attached joints.\n\t\tJointEdge je = body.m_jointList;\n\t\twhile (je != null) {\n\t\t\tJointEdge je0 = je;\n\t\t\tje = je.next;\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(je0.joint);\n\t\t\t}\n\n\t\t\tdestroyJoint(je0.joint);\n\n\t\t\tbody.m_jointList = je;\n\t\t}\n\t\tbody.m_jointList = null;\n\n\t\t// Delete the attached contacts.\n\t\tContactEdge ce = body.m_contactList;\n\t\twhile (ce != null) {\n\t\t\tContactEdge ce0 = ce;\n\t\t\tce = ce.next;\n\t\t\tm_contactManager.destroy(ce0.contact);\n\t\t}\n\t\tbody.m_contactList = null;\n\n\t\tFixture f = body.m_fixtureList;\n\t\twhile (f != null) {\n\t\t\tFixture f0 = f;\n\t\t\tf = f.m_next;\n\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(f0);\n\t\t\t}\n\n\t\t\tf0.destroyProxies(m_contactManager.m_broadPhase);\n\t\t\tf0.destroy();\n\t\t\t// TODO djm recycle fixtures (here or in that destroy method)\n\t\t\tbody.m_fixtureList = f;\n\t\t\tbody.m_fixtureCount -= 1;\n\t\t}\n\t\tbody.m_fixtureList = null;\n\t\tbody.m_fixtureCount = 0;\n\n\t\t// Remove world body list.\n\t\tif (body.m_prev != null) {\n\t\t\tbody.m_prev.m_next = body.m_next;\n\t\t}\n\n\t\tif (body.m_next != null) {\n\t\t\tbody.m_next.m_prev = body.m_prev;\n\t\t}\n\n\t\tif (body == m_bodyList) {\n\t\t\tm_bodyList = body.m_next;\n\t\t}\n\n\t\t--m_bodyCount;\n\t\t// TODO djm recycle body\n\t}\n\n\t/** create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected\n\t * bodies to cease colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Joint createJoint (JointDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJoint j = Joint.create(this, def);\n\n\t\t// Connect to the world list.\n\t\tj.m_prev = null;\n\t\tj.m_next = m_jointList;\n\t\tif (m_jointList != null) {\n\t\t\tm_jointList.m_prev = j;\n\t\t}\n\t\tm_jointList = j;\n\t\t++m_jointCount;\n\n\t\t// Connect to the bodies\' doubly linked lists.\n\t\tj.m_edgeA.joint = j;\n\t\tj.m_edgeA.other = j.getBodyB();\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = j.getBodyA().m_jointList;\n\t\tif (j.getBodyA().m_jointList != null) {\n\t\t\tj.getBodyA().m_jointList.prev = j.m_edgeA;\n\t\t}\n\t\tj.getBodyA().m_jointList = j.m_edgeA;\n\n\t\tj.m_edgeB.joint = j;\n\t\tj.m_edgeB.other = j.getBodyA();\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = j.getBodyB().m_jointList;\n\t\tif (j.getBodyB().m_jointList != null) {\n\t\t\tj.getBodyB().m_jointList.prev = j.m_edgeB;\n\t\t}\n\t\tj.getBodyB().m_jointList = j.m_edgeB;\n\n\t\tBody bodyA = def.bodyA;\n\t\tBody bodyB = def.bodyB;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (def.collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\n\t\t// Note: creating a joint doesn\'t wake the bodies.\n\n\t\treturn j;\n\t}\n\n\t/** destroy a joint. This may cause the connected bodies to begin colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param joint */\n\tpublic void destroyJoint (Joint j) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\tboolean collideConnected = j.getCollideConnected();\n\n\t\t// Remove from the doubly linked list.\n\t\tif (j.m_prev != null) {\n\t\t\tj.m_prev.m_next = j.m_next;\n\t\t}\n\n\t\tif (j.m_next != null) {\n\t\t\tj.m_next.m_prev = j.m_prev;\n\t\t}\n\n\t\tif (j == m_jointList) {\n\t\t\tm_jointList = j.m_next;\n\t\t}\n\n\t\t// Disconnect from island graph.\n\t\tBody bodyA = j.getBodyA();\n\t\tBody bodyB = j.getBodyB();\n\n\t\t// Wake up connected bodies.\n\t\tbodyA.setAwake(true);\n\t\tbodyB.setAwake(true);\n\n\t\t// Remove from body 1.\n\t\tif (j.m_edgeA.prev != null) {\n\t\t\tj.m_edgeA.prev.next = j.m_edgeA.next;\n\t\t}\n\n\t\tif (j.m_edgeA.next != null) {\n\t\t\tj.m_edgeA.next.prev = j.m_edgeA.prev;\n\t\t}\n\n\t\tif (j.m_edgeA == bodyA.m_jointList) {\n\t\t\tbodyA.m_jointList = j.m_edgeA.next;\n\t\t}\n\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = null;\n\n\t\t// Remove from body 2\n\t\tif (j.m_edgeB.prev != null) {\n\t\t\tj.m_edgeB.prev.next = j.m_edgeB.next;\n\t\t}\n\n\t\tif (j.m_edgeB.next != null) {\n\t\t\tj.m_edgeB.next.prev = j.m_edgeB.prev;\n\t\t}\n\n\t\tif (j.m_edgeB == bodyB.m_jointList) {\n\t\t\tbodyB.m_jointList = j.m_edgeB.next;\n\t\t}\n\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = null;\n\n\t\tJoint.destroy(j);\n\n\t\tassert (m_jointCount \> 0);\n\t\t--m_jointCount;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\t}\n\n\t// djm pooling\n\tprivate final TimeStep step = new TimeStep();\n\tprivate final Timer stepTimer = new Timer();\n\tprivate final Timer tempTimer = new Timer();\n\n\t/** Take a time step. This performs collision detection, integration, and constraint solution.\n\t * \n\t * @param timeStep the amount of time to simulate, this should not vary.\n\t * @param velocityIterations for the velocity constraint solver.\n\t * @param positionIterations for the position constraint solver. */\n\tpublic void step (float dt, int velocityIterations, int positionIterations) {\n\t\tstepTimer.reset();\n\t\ttempTimer.reset();\n\t\t// log.debug(\"Starting step\");\n\t\t// If new fixtures were added, we need to find the new contacts.\n\t\tif ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\n\t\t\t// log.debug(\"There\'s a new fixture, lets look for new contacts\");\n\t\t\tm_contactManager.findNewContacts();\n\t\t\tm_flags &= ~NEW_FIXTURE;\n\t\t}\n\n\t\tm_flags |= LOCKED;\n\n\t\tstep.dt = dt;\n\t\tstep.velocityIterations = velocityIterations;\n\t\tstep.positionIterations = positionIterations;\n\t\tif (dt \> 0.0f) {\n\t\t\tstep.inv_dt = 1.0f / dt;\n\t\t} else {\n\t\t\tstep.inv_dt = 0.0f;\n\t\t}\n\n\t\tstep.dtRatio = m_inv_dt0 * dt;\n\n\t\tstep.warmStarting = m_warmStarting;\n\t\tm_profile.stepInit.record(tempTimer.getMilliseconds());\n\n\t\t// Update contacts. This is where some contacts are destroyed.\n\t\ttempTimer.reset();\n\t\tm_contactManager.collide();\n\t\tm_profile.collide.record(tempTimer.getMilliseconds());\n\n\t\t// Integrate velocities, solve velocity constraints, and integrate positions.\n\t\tif (m_stepComplete && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tm_particleSystem.solve(step); // Particle Simulation\n\t\t\tm_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\n\t\t\ttempTimer.reset();\n\t\t\tsolve(step);\n\t\t\tm_profile.solve.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\t// Handle TOI events.\n\t\tif (m_continuousPhysics && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tsolveTOI(step);\n\t\t\tm_profile.solveTOI.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\tif (step.dt \> 0.0f) {\n\t\t\tm_inv_dt0 = step.inv_dt;\n\t\t}\n\n\t\tif ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\n\t\t\tclearForces();\n\t\t}\n\n\t\tm_flags &= ~LOCKED;\n\t\t// log.debug(\"ending step\");\n\n\t\tm_profile.step.record(stepTimer.getMilliseconds());\n\t}\n\n\t/** Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless\n\t * you are performing sub-steps. By default, forces will be automatically cleared, so you don\'t need to call this function.\n\t * \n\t * @see setAutoClearForces */\n\tpublic void clearForces () {\n\t\tfor (Body body = m_bodyList; body != null; body = body.getNext()) {\n\t\t\tbody.m_force.setZero();\n\t\t\tbody.m_torque = 0.0f;\n\t\t}\n\t}\n\n\tprivate final Color3f color = new Color3f();\n\tprivate final Transform xf = new Transform();\n\tprivate final Vec2 cA = new Vec2();\n\tprivate final Vec2 cB = new Vec2();\n\tprivate final Vec2Array avs = new Vec2Array();\n\n\t/** Call this to draw shapes and other debug draw data. */\n\tpublic void drawDebugData () {\n\t\tif (m_debugDraw == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint flags = m_debugDraw.getFlags();\n\t\tboolean wireframe = (flags & DebugDraw.e_wireframeDrawingBit) != 0;\n\n\t\tif ((flags & DebugDraw.e_shapeBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.STATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.9f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.KINEMATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.9f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.isAwake() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.5f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolor.set(0.9f, 0.7f, 0.7f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawParticleSystem(m_particleSystem);\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_jointBit) != 0) {\n\t\t\tfor (Joint j = m_jointList; j != null; j = j.getNext()) {\n\t\t\t\tdrawJoint(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_pairBit) != 0) {\n\t\t\tcolor.set(0.3f, 0.9f, 0.9f);\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.getNext()) {\n\t\t\t\tFixture fixtureA = c.getFixtureA();\n\t\t\t\tFixture fixtureB = c.getFixtureB();\n\t\t\t\tfixtureA.getAABB(c.getChildIndexA()).getCenterToOut(cA);\n\t\t\t\tfixtureB.getAABB(c.getChildIndexB()).getCenterToOut(cB);\n\t\t\t\tm_debugDraw.drawSegment(cA, cB, color);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_aabbBit) != 0) {\n\t\t\tcolor.set(0.9f, 0.3f, 0.9f);\n\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tfor (int i = 0; i \< f.m_proxyCount; ++i) {\n\t\t\t\t\t\tFixtureProxy proxy = f.m_proxies[i];\n\t\t\t\t\t\tAABB aabb = m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);\n\t\t\t\t\t\tif (aabb != null) {\n\t\t\t\t\t\t\tVec2[] vs = avs.get(4);\n\t\t\t\t\t\t\tvs[0].set(aabb.lowerBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[1].set(aabb.upperBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[2].set(aabb.upperBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tvs[3].set(aabb.lowerBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tm_debugDraw.drawPolygon(vs, 4, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_centerOfMassBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\txf.p.set(b.getWorldCenter());\n\t\t\t\tm_debugDraw.drawTransform(xf);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_dynamicTreeBit) != 0) {\n\t\t\tm_contactManager.m_broadPhase.drawTree(m_debugDraw);\n\t\t}\n\n\t\tm_debugDraw.flush();\n\t}\n\n\tprivate final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();\n\n\t/** Query the world for all fixtures that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t}\n\n\t/** Query the world for all fixtures and particles that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\t/** Query the world for all particles that potentially overlap the provided AABB.\n\t * \n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (ParticleQueryCallback particleCallback, AABB aabb) {\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\tprivate final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();\n\tprivate final RayCastInput input = new RayCastInput();\n\n\t/** Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t}\n\n\t/** Ray-cast the world for all fixtures and particles in the path of the ray. Your callback controls whether you get the\n\t * closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Ray-cast the world for all particles in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points.\n\t * \n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Get the world body list. With the returned body, use Body.getNext to get the next body in the world list. A null body\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world body list. */\n\tpublic Body getBodyList () {\n\t\treturn m_bodyList;\n\t}\n\n\t/** Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in the world list. A null joint\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world joint list. */\n\tpublic Joint getJointList () {\n\t\treturn m_jointList;\n\t}\n\n\t/** Get the world contact list. With the returned contact, use Contact.getNext to get the next contact in the world list. A\n\t * null contact indicates the end of the list.\n\t * \n\t * @return the head of the world contact list.\n\t * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener to avoid missing contacts. */\n\tpublic Contact getContactList () {\n\t\treturn m_contactManager.m_contactList;\n\t}\n\n\tpublic boolean isSleepingAllowed () {\n\t\treturn m_allowSleep;\n\t}\n\n\tpublic void setSleepingAllowed (boolean sleepingAllowed) {\n\t\tm_allowSleep = sleepingAllowed;\n\t}\n\n\t/** Enable/disable warm starting. For testing.\n\t * \n\t * @param flag */\n\tpublic void setWarmStarting (boolean flag) {\n\t\tm_warmStarting = flag;\n\t}\n\n\tpublic boolean isWarmStarting () {\n\t\treturn m_warmStarting;\n\t}\n\n\t/** Enable/disable continuous physics. For testing.\n\t * \n\t * @param flag */\n\tpublic void setContinuousPhysics (boolean flag) {\n\t\tm_continuousPhysics = flag;\n\t}\n\n\tpublic boolean isContinuousPhysics () {\n\t\treturn m_continuousPhysics;\n\t}\n\n\t/** Get the number of broad-phase proxies.\n\t * \n\t * @return */\n\tpublic int getProxyCount () {\n\t\treturn m_contactManager.m_broadPhase.getProxyCount();\n\t}\n\n\t/** Get the number of bodies.\n\t * \n\t * @return */\n\tpublic int getBodyCount () {\n\t\treturn m_bodyCount;\n\t}\n\n\t/** Get the number of joints.\n\t * \n\t * @return */\n\tpublic int getJointCount () {\n\t\treturn m_jointCount;\n\t}\n\n\t/** Get the number of contacts (each may have 0 or more contact points).\n\t * \n\t * @return */\n\tpublic int getContactCount () {\n\t\treturn m_contactManager.m_contactCount;\n\t}\n\n\t/** Gets the height of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeHeight () {\n\t\treturn m_contactManager.m_broadPhase.getTreeHeight();\n\t}\n\n\t/** Gets the balance of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeBalance () {\n\t\treturn m_contactManager.m_broadPhase.getTreeBalance();\n\t}\n\n\t/** Gets the quality of the dynamic tree\n\t * \n\t * @return */\n\tpublic float getTreeQuality () {\n\t\treturn m_contactManager.m_broadPhase.getTreeQuality();\n\t}\n\n\t/** Change the global gravity vector.\n\t * \n\t * @param gravity */\n\tpublic void setGravity (Vec2 gravity) {\n\t\tm_gravity.set(gravity);\n\t}\n\n\t/** Get the global gravity vector.\n\t * \n\t * @return */\n\tpublic Vec2 getGravity () {\n\t\treturn m_gravity;\n\t}\n\n\t/** Is the world locked (in the middle of a time step).\n\t * \n\t * @return */\n\tpublic boolean isLocked () {\n\t\treturn (m_flags & LOCKED) == LOCKED;\n\t}\n\n\t/** Set flag to control automatic clearing of forces after each time step.\n\t * \n\t * @param flag */\n\tpublic void setAutoClearForces (boolean flag) {\n\t\tif (flag) {\n\t\t\tm_flags |= CLEAR_FORCES;\n\t\t} else {\n\t\t\tm_flags &= ~CLEAR_FORCES;\n\t\t}\n\t}\n\n\t/** Get the flag that controls automatic clearing of forces after each time step.\n\t * \n\t * @return */\n\tpublic boolean getAutoClearForces () {\n\t\treturn (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\n\t}\n\n\t/** Get the contact manager for testing purposes\n\t * \n\t * @return */\n\tpublic ContactManager getContactManager () {\n\t\treturn m_contactManager;\n\t}\n\n\tpublic Profile getProfile () {\n\t\treturn m_profile;\n\t}\n\n\tprivate final Island island = new Island();\n\tprivate Body[] stack = new Body[10]; // TODO djm find a good initial stack number;\n\tprivate final Timer broadphaseTimer = new Timer();\n\n\tprivate void solve (TimeStep step) {\n\t\tm_profile.solveInit.startAccum();\n\t\tm_profile.solveVelocity.startAccum();\n\t\tm_profile.solvePosition.startAccum();\n\n\t\t// update previous transforms\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_xf0.set(b.m_xf);\n\t\t}\n\n\t\t// Size the island for the worst case.\n\t\tisland.init(m_bodyCount, m_contactManager.m_contactCount, m_jointCount, m_contactManager.m_contactListener);\n\n\t\t// Clear all the island flags.\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t}\n\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\tc.m_flags &= ~Contact.ISLAND_FLAG;\n\t\t}\n\t\tfor (Joint j = m_jointList; j != null; j = j.m_next) {\n\t\t\tj.m_islandFlag = false;\n\t\t}\n\n\t\t// Build and simulate all awake islands.\n\t\tint stackSize = m_bodyCount;\n\t\tif (stack.length \< stackSize) {\n\t\t\tstack = new Body[stackSize];\n\t\t}\n\t\tfor (Body seed = m_bodyList; seed != null; seed = seed.m_next) {\n\t\t\tif ((seed.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (seed.isAwake() == false || seed.isActive() == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The seed can be dynamic or kinematic.\n\t\t\tif (seed.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Reset island and stack.\n\t\t\tisland.clear();\n\t\t\tint stackCount = 0;\n\t\t\tstack[stackCount++] = seed;\n\t\t\tseed.m_flags |= Body.e_islandFlag;\n\n\t\t\t// Perform a depth first search (DFS) on the constraint graph.\n\t\t\twhile (stackCount \> 0) {\n\t\t\t\t// Grab the next body off the stack and add it to the island.\n\t\t\t\tBody b = stack[--stackCount];\n\t\t\t\tassert (b.isActive() == true);\n\t\t\t\tisland.add(b);\n\n\t\t\t\t// Make sure the body is awake.\n\t\t\t\tb.setAwake(true);\n\n\t\t\t\t// To keep islands as small as possible, we don\'t\n\t\t\t\t// propagate islands across static bodies.\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Search all contacts connected to this body.\n\t\t\t\tfor (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t// Has this contact already been added to an island?\n\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Is this contact solid and touching?\n\t\t\t\t\tif (contact.isEnabled() == false || contact.isTouching() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip sensors.\n\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(contact);\n\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t\t\tBody other = ce.other;\n\n\t\t\t\t\t// Was the other body already added to this island?\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\n\t\t\t\t// Search all joints connect to this body.\n\t\t\t\tfor (JointEdge je = b.m_jointList; je != null; je = je.next) {\n\t\t\t\t\tif (je.joint.m_islandFlag == true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody other = je.other;\n\n\t\t\t\t\t// Don\'t simulate joints connected to inactive bodies.\n\t\t\t\t\tif (other.isActive() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(je.joint);\n\t\t\t\t\tje.joint.m_islandFlag = true;\n\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tisland.solve(m_profile, step, m_gravity, m_allowSleep);\n\n\t\t\t// Post solve cleanup.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\t// Allow static bodies to participate in other islands.\n\t\t\t\tBody b = island.m_bodies[i];\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm_profile.solveInit.endAccum();\n\t\tm_profile.solveVelocity.endAccum();\n\t\tm_profile.solvePosition.endAccum();\n\n\t\tbroadphaseTimer.reset();\n\t\t// Synchronize fixtures, check for out of range bodies.\n\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t// If a body was not in an island then it did not move.\n\t\t\tif ((b.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Update fixtures (for broad-phase).\n\t\t\tb.synchronizeFixtures();\n\t\t}\n\n\t\t// Look for new contacts.\n\t\tm_contactManager.findNewContacts();\n\t\tm_profile.broadphase.record(broadphaseTimer.getMilliseconds());\n\t}\n\n\tprivate final Island toiIsland = new Island();\n\tprivate final TOIInput toiInput = new TOIInput();\n\tprivate final TOIOutput toiOutput = new TOIOutput();\n\tprivate final TimeStep subStep = new TimeStep();\n\tprivate final Body[] tempBodies = new Body[2];\n\tprivate final Sweep backup1 = new Sweep();\n\tprivate final Sweep backup2 = new Sweep();\n\n\tprivate void solveTOI (final TimeStep step) {\n\n\t\tfinal Island island = toiIsland;\n\t\tisland.init(2 * Settings.maxTOIContacts, Settings.maxTOIContacts, 0, m_contactManager.m_contactListener);\n\t\tif (m_stepComplete) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\tb.m_sweep.alpha0 = 0.0f;\n\t\t\t}\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Invalidate TOI\n\t\t\t\tc.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\tc.m_toiCount = 0;\n\t\t\t\tc.m_toi = 1.0f;\n\t\t\t}\n\t\t}\n\n\t\t// Find TOI events and solve them.\n\t\tfor (;;) {\n\t\t\t// Find the first TOI.\n\t\t\tContact minContact = null;\n\t\t\tfloat minAlpha = 1.0f;\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Is this contact disabled?\n\t\t\t\tif (c.isEnabled() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Prevent excessive sub-stepping.\n\t\t\t\tif (c.m_toiCount \> Settings.maxSubSteps) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat alpha = 1.0f;\n\t\t\t\tif ((c.m_flags & Contact.TOI_FLAG) != 0) {\n\t\t\t\t\t// This contact has a valid cached TOI.\n\t\t\t\t\talpha = c.m_toi;\n\t\t\t\t} else {\n\t\t\t\t\tFixture fA = c.getFixtureA();\n\t\t\t\t\tFixture fB = c.getFixtureB();\n\n\t\t\t\t\t// Is there a sensor?\n\t\t\t\t\tif (fA.isSensor() || fB.isSensor()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody bA = fA.getBody();\n\t\t\t\t\tBody bB = fB.getBody();\n\n\t\t\t\t\tBodyType typeA = bA.m_type;\n\t\t\t\t\tBodyType typeB = bB.m_type;\n\t\t\t\t\tassert (typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC);\n\n\t\t\t\t\tboolean activeA = bA.isAwake() && typeA != BodyType.STATIC;\n\t\t\t\t\tboolean activeB = bB.isAwake() && typeB != BodyType.STATIC;\n\n\t\t\t\t\t// Is at least one body active (awake and dynamic or kinematic)?\n\t\t\t\t\tif (activeA == false && activeB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;\n\t\t\t\t\tboolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;\n\n\t\t\t\t\t// Are these two non-bullet dynamic bodies?\n\t\t\t\t\tif (collideA == false && collideB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute the TOI for this contact.\n\t\t\t\t\t// Put the sweeps onto the same time interval.\n\t\t\t\t\tfloat alpha0 = bA.m_sweep.alpha0;\n\n\t\t\t\t\tif (bA.m_sweep.alpha0 \< bB.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bB.m_sweep.alpha0;\n\t\t\t\t\t\tbA.m_sweep.advance(alpha0);\n\t\t\t\t\t} else if (bB.m_sweep.alpha0 \< bA.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bA.m_sweep.alpha0;\n\t\t\t\t\t\tbB.m_sweep.advance(alpha0);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (alpha0 \< 1.0f);\n\n\t\t\t\t\tint indexA = c.getChildIndexA();\n\t\t\t\t\tint indexB = c.getChildIndexB();\n\n\t\t\t\t\t// Compute the time of impact in interval [0, minTOI]\n\t\t\t\t\tfinal TOIInput input = toiInput;\n\t\t\t\t\tinput.proxyA.set(fA.getShape(), indexA);\n\t\t\t\t\tinput.proxyB.set(fB.getShape(), indexB);\n\t\t\t\t\tinput.sweepA.set(bA.m_sweep);\n\t\t\t\t\tinput.sweepB.set(bB.m_sweep);\n\t\t\t\t\tinput.tMax = 1.0f;\n\n\t\t\t\t\tpool.getTimeOfImpact().timeOfImpact(toiOutput, input);\n\n\t\t\t\t\t// Beta is the fraction of the remaining portion of the .\n\t\t\t\t\tfloat beta = toiOutput.t;\n\t\t\t\t\tif (toiOutput.state == TOIOutputState.TOUCHING) {\n\t\t\t\t\t\talpha = MathUtils.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talpha = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.m_toi = alpha;\n\t\t\t\t\tc.m_flags |= Contact.TOI_FLAG;\n\t\t\t\t}\n\n\t\t\t\tif (alpha \< minAlpha) {\n\t\t\t\t\t// This is the minimum TOI found so far.\n\t\t\t\t\tminContact = c;\n\t\t\t\t\tminAlpha = alpha;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minContact == null || 1.0f - 10.0f * Settings.EPSILON \< minAlpha) {\n\t\t\t\t// No more TOI events. Done!\n\t\t\t\tm_stepComplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Advance the bodies to the TOI.\n\t\t\tFixture fA = minContact.getFixtureA();\n\t\t\tFixture fB = minContact.getFixtureB();\n\t\t\tBody bA = fA.getBody();\n\t\t\tBody bB = fB.getBody();\n\n\t\t\tbackup1.set(bA.m_sweep);\n\t\t\tbackup2.set(bB.m_sweep);\n\n\t\t\tbA.advance(minAlpha);\n\t\t\tbB.advance(minAlpha);\n\n\t\t\t// The TOI contact likely has some new contact points.\n\t\t\tminContact.update(m_contactManager.m_contactListener);\n\t\t\tminContact.m_flags &= ~Contact.TOI_FLAG;\n\t\t\t++minContact.m_toiCount;\n\n\t\t\t// Is the contact solid?\n\t\t\tif (minContact.isEnabled() == false || minContact.isTouching() == false) {\n\t\t\t\t// Restore the sweeps.\n\t\t\t\tminContact.setEnabled(false);\n\t\t\t\tbA.m_sweep.set(backup1);\n\t\t\t\tbB.m_sweep.set(backup2);\n\t\t\t\tbA.synchronizeTransform();\n\t\t\t\tbB.synchronizeTransform();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbA.setAwake(true);\n\t\t\tbB.setAwake(true);\n\n\t\t\t// Build the island\n\t\t\tisland.clear();\n\t\t\tisland.add(bA);\n\t\t\tisland.add(bB);\n\t\t\tisland.add(minContact);\n\n\t\t\tbA.m_flags |= Body.e_islandFlag;\n\t\t\tbB.m_flags |= Body.e_islandFlag;\n\t\t\tminContact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t// Get contacts on bodyA and bodyB.\n\t\t\ttempBodies[0] = bA;\n\t\t\ttempBodies[1] = bB;\n\t\t\tfor (int i = 0; i \< 2; ++i) {\n\t\t\t\tBody body = tempBodies[i];\n\t\t\t\tif (body.m_type == BodyType.DYNAMIC) {\n\t\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\t\tif (island.m_bodyCount == island.m_bodyCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (island.m_contactCount == island.m_contactCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t\t// Has this contact already been added to the island?\n\t\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only add static, kinematic, or bullet bodies.\n\t\t\t\t\t\tBody other = ce.other;\n\t\t\t\t\t\tif (other.m_type == BodyType.DYNAMIC && body.isBullet() == false && other.isBullet() == false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Skip sensors.\n\t\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Tentatively advance the body to the TOI.\n\t\t\t\t\t\tbackup1.set(other.m_sweep);\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\t\t\t\tother.advance(minAlpha);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the contact points\n\t\t\t\t\t\tcontact.update(m_contactManager.m_contactListener);\n\n\t\t\t\t\t\t// Was the contact disabled by the user?\n\t\t\t\t\t\tif (contact.isEnabled() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Are there contact points?\n\t\t\t\t\t\tif (contact.isTouching() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the contact to the island\n\t\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\t\t\t\t\t\tisland.add(contact);\n\n\t\t\t\t\t\t// Has the other body already been added to the island?\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the other body to the island.\n\t\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\n\t\t\t\t\t\tif (other.m_type != BodyType.STATIC) {\n\t\t\t\t\t\t\tother.setAwake(true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tisland.add(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsubStep.dt = (1.0f - minAlpha) * step.dt;\n\t\t\tsubStep.inv_dt = 1.0f / subStep.dt;\n\t\t\tsubStep.dtRatio = 1.0f;\n\t\t\tsubStep.positionIterations = 20;\n\t\t\tsubStep.velocityIterations = step.velocityIterations;\n\t\t\tsubStep.warmStarting = false;\n\t\t\tisland.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\n\n\t\t\t// Reset island flags and synchronize broad-phase proxies.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\tBody body = island.m_bodies[i];\n\t\t\t\tbody.m_flags &= ~Body.e_islandFlag;\n\n\t\t\t\tif (body.m_type != BodyType.DYNAMIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbody.synchronizeFixtures();\n\n\t\t\t\t// Invalidate all contact TOIs on this displaced body.\n\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tce.contact.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commit fixture proxy movements to the broad-phase so that new contacts are created.\n\t\t\t// Also, some contacts can be destroyed.\n\t\t\tm_contactManager.findNewContacts();\n\n\t\t\tif (m_subStepping) {\n\t\t\t\tm_stepComplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void drawJoint (Joint joint) {\n\t\tBody bodyA = joint.getBodyA();\n\t\tBody bodyB = joint.getBodyB();\n\t\tTransform xf1 = bodyA.getTransform();\n\t\tTransform xf2 = bodyB.getTransform();\n\t\tVec2 x1 = xf1.p;\n\t\tVec2 x2 = xf2.p;\n\t\tVec2 p1 = pool.popVec2();\n\t\tVec2 p2 = pool.popVec2();\n\t\tjoint.getAnchorA(p1);\n\t\tjoint.getAnchorB(p2);\n\n\t\tcolor.set(0.5f, 0.8f, 0.8f);\n\n\t\tswitch (joint.getType()) {\n\t\t// TODO djm write after writing joints\n\t\tcase DISTANCE:\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tbreak;\n\n\t\tcase PULLEY: {\n\t\t\tPulleyJoint pulley = (PulleyJoint)joint;\n\t\t\tVec2 s1 = pulley.getGroundAnchorA();\n\t\t\tVec2 s2 = pulley.getGroundAnchorB();\n\t\t\tm_debugDraw.drawSegment(s1, p1, color);\n\t\t\tm_debugDraw.drawSegment(s2, p2, color);\n\t\t\tm_debugDraw.drawSegment(s1, s2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CONSTANT_VOLUME:\n\t\tcase MOUSE:\n\t\t\t// don\'t draw this\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tm_debugDraw.drawSegment(x1, p1, color);\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tm_debugDraw.drawSegment(x2, p2, color);\n\t\t}\n\t\tpool.pushVec2(2);\n\t}\n\n\t// NOTE this corresponds to the liquid test, so the debugdraw can draw\n\t// the liquid particles correctly. They should be the same.\n\tprivate static Integer LIQUID_INT = new Integer(1234598372);\n\tprivate float liquidLength = .12f;\n\tprivate float averageLinearVel = -1;\n\tprivate final Vec2 liquidOffset = new Vec2();\n\tprivate final Vec2 circCenterMoved = new Vec2();\n\tprivate final Color3f liquidColor = new Color3f(.4f, .4f, 1f);\n\n\tprivate final Vec2 center = new Vec2();\n\tprivate final Vec2 axis = new Vec2();\n\tprivate final Vec2 v1 = new Vec2();\n\tprivate final Vec2 v2 = new Vec2();\n\tprivate final Vec2Array tlvertices = new Vec2Array();\n\n\tprivate void drawShape (Fixture fixture, Transform xf, Color3f color, boolean wireframe) {\n\t\tswitch (fixture.getType()) {\n\t\tcase CIRCLE: {\n\t\t\tCircleShape circle = (CircleShape)fixture.getShape();\n\n\t\t\t// Vec2 center = Mul(xf, circle.m_p);\n\t\t\tTransform.mulToOutUnsafe(xf, circle.m_p, center);\n\t\t\tfloat radius = circle.m_radius;\n\t\t\txf.q.getXAxis(axis);\n\n\t\t\tif (fixture.getUserData() != null && fixture.getUserData().equals(LIQUID_INT)) {\n\t\t\t\tBody b = fixture.getBody();\n\t\t\t\tliquidOffset.set(b.m_linearVelocity);\n\t\t\t\tfloat linVelLength = b.m_linearVelocity.length();\n\t\t\t\tif (averageLinearVel == -1) {\n\t\t\t\t\taverageLinearVel = linVelLength;\n\t\t\t\t} else {\n\t\t\t\t\taverageLinearVel = .98f * averageLinearVel + .02f * linVelLength;\n\t\t\t\t}\n\t\t\t\tliquidOffset.mulLocal(liquidLength / averageLinearVel / 2);\n\t\t\t\tcircCenterMoved.set(center).addLocal(liquidOffset);\n\t\t\t\tcenter.subLocal(liquidOffset);\n\t\t\t\tm_debugDraw.drawSegment(center, circCenterMoved, liquidColor);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawCircle(center, radius, axis, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidCircle(center, radius, axis, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase POLYGON: {\n\t\t\tPolygonShape poly = (PolygonShape)fixture.getShape();\n\t\t\tint vertexCount = poly.m_count;\n\t\t\tassert (vertexCount \<= Settings.maxPolygonVertices);\n\t\t\tVec2[] vertices = tlvertices.get(Settings.maxPolygonVertices);\n\n\t\t\tfor (int i = 0; i \< vertexCount; ++i) {\n\t\t\t\t// vertices[i] = Mul(xf, poly.m_vertices[i]);\n\t\t\t\tTransform.mulToOutUnsafe(xf, poly.m_vertices[i], vertices[i]);\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawPolygon(vertices, vertexCount, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidPolygon(vertices, vertexCount, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase EDGE: {\n\t\t\tEdgeShape edge = (EdgeShape)fixture.getShape();\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex1, v1);\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex2, v2);\n\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CHAIN: {\n\t\t\tChainShape chain = (ChainShape)fixture.getShape();\n\t\t\tint count = chain.m_count;\n\t\t\tVec2[] vertices = chain.m_vertices;\n\n\t\t\tTransform.mulToOutUnsafe(xf, vertices[0], v1);\n\t\t\tfor (int i = 1; i \< count; ++i) {\n\t\t\t\tTransform.mulToOutUnsafe(xf, vertices[i], v2);\n\t\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t\t\tm_debugDraw.drawCircle(v1, 0.05f, color);\n\t\t\t\tv1.set(v2);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void drawParticleSystem (ParticleSystem system) {\n\t\tboolean wireframe = (m_debugDraw.getFlags() & DebugDraw.e_wireframeDrawingBit) != 0;\n\t\tint particleCount = system.getParticleCount();\n\t\tif (particleCount != 0) {\n\t\t\tfloat particleRadius = system.getParticleRadius();\n\t\t\tVec2[] positionBuffer = system.getParticlePositionBuffer();\n\t\t\tParticleColor[] colorBuffer = null;\n\t\t\tif (system.m_colorBuffer.data != null) {\n\t\t\t\tcolorBuffer = system.getParticleColorBuffer();\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawParticlesWireframe(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawParticles(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Create a particle whose properties have been defined. No reference to the definition is retained. A simulation step must\n\t * occur before it\'s possible to interact with a newly created particle. For example, DestroyParticleInShape() will not destroy\n\t * a particle until Step() has been called.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @return the index of the particle. */\n\tpublic int createParticle (ParticleDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint p = m_particleSystem.createParticle(def);\n\t\treturn p;\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param index */\n\tpublic void destroyParticle (int index) {\n\t\tdestroyParticle(index, false);\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param Index of the particle to destroy.\n\t * @param Whether to call the destruction listener just before the particle is destroyed. */\n\tpublic void destroyParticle (int index, boolean callDestructionListener) {\n\t\tm_particleSystem.destroyParticle(index, callDestructionListener);\n\t}\n\n\t/** Destroy particles inside a shape without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks. For more information see DestroyParticleInShape(Shape&, Transform&,bool).\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf) {\n\t\treturn destroyParticlesInShape(shape, xf, false);\n\t}\n\n\t/** Destroy particles inside a shape. This function is locked during callbacks. In addition, this function immediately destroys\n\t * particles in the shape in contrast to DestroyParticle() which defers the destruction until the next simulation step.\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @param Whether to call the world b2DestructionListener for each particle destroyed.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn m_particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);\n\t}\n\n\t/** Create a particle group whose properties have been defined. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks. */\n\tpublic ParticleGroup createParticleGroup (ParticleGroupDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\tParticleGroup g = m_particleSystem.createParticleGroup(def);\n\t\treturn g;\n\t}\n\n\t/** Join two particle groups.\n\t * \n\t * @param the first group. Expands to encompass the second group.\n\t * @param the second group. It is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void joinParticleGroups (ParticleGroup groupA, ParticleGroup groupB) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.joinParticleGroups(groupA, groupB);\n\t}\n\n\t/** Destroy particles in a group. This function is locked during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @param Whether to call the world b2DestructionListener for each particle is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.destroyParticlesInGroup(group, callDestructionListener);\n\t}\n\n\t/** Destroy particles in a group without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group) {\n\t\tdestroyParticlesInGroup(group, false);\n\t}\n\n\t/** Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get the next group in the world\n\t * list. A NULL group indicates the end of the list.\n\t * \n\t * @return the head of the world particle group list. */\n\tpublic ParticleGroup[] getParticleGroupList () {\n\t\treturn m_particleSystem.getParticleGroupList();\n\t}\n\n\t/** Get the number of particle groups.\n\t * \n\t * @return */\n\tpublic int getParticleGroupCount () {\n\t\treturn m_particleSystem.getParticleGroupCount();\n\t}\n\n\t/** Get the number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleCount () {\n\t\treturn m_particleSystem.getParticleCount();\n\t}\n\n\t/** Get the maximum number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleMaxCount () {\n\t\treturn m_particleSystem.getParticleMaxCount();\n\t}\n\n\t/** Set the maximum number of particles.\n\t * \n\t * @param count */\n\tpublic void setParticleMaxCount (int count) {\n\t\tm_particleSystem.setParticleMaxCount(count);\n\t}\n\n\t/** Change the particle density.\n\t * \n\t * @param density */\n\tpublic void setParticleDensity (float density) {\n\t\tm_particleSystem.setParticleDensity(density);\n\t}\n\n\t/** Get the particle density.\n\t * \n\t * @return */\n\tpublic float getParticleDensity () {\n\t\treturn m_particleSystem.getParticleDensity();\n\t}\n\n\t/** Change the particle gravity scale. Adjusts the effect of the global gravity vector on particles. Default value is 1.0f.\n\t * \n\t * @param gravityScale */\n\tpublic void setParticleGravityScale (float gravityScale) {\n\t\tm_particleSystem.setParticleGravityScale(gravityScale);\n\n\t}\n\n\t/** Get the particle gravity scale.\n\t * \n\t * @return */\n\tpublic float getParticleGravityScale () {\n\t\treturn m_particleSystem.getParticleGravityScale();\n\t}\n\n\t/** Damping is used to reduce the velocity of particles. The damping parameter can be larger than 1.0f but the damping effect\n\t * becomes sensitive to the time step when the damping parameter is large.\n\t * \n\t * @param damping */\n\tpublic void setParticleDamping (float damping) {\n\t\tm_particleSystem.setParticleDamping(damping);\n\t}\n\n\t/** Get damping for particles\n\t * \n\t * @return */\n\tpublic float getParticleDamping () {\n\t\treturn m_particleSystem.getParticleDamping();\n\t}\n\n\t/** Change the particle radius. You should set this only once, on world start. If you change the radius during execution,\n\t * existing particles may explode, shrink, or behave unexpectedly.\n\t * \n\t * @param radius */\n\tpublic void setParticleRadius (float radius) {\n\t\tm_particleSystem.setParticleRadius(radius);\n\t}\n\n\t/** Get the particle radius.\n\t * \n\t * @return */\n\tpublic float getParticleRadius () {\n\t\treturn m_particleSystem.getParticleRadius();\n\t}\n\n\t/** Get the particle data. @return the pointer to the head of the particle data.\n\t * \n\t * @return */\n\tpublic int[] getParticleFlagsBuffer () {\n\t\treturn m_particleSystem.getParticleFlagsBuffer();\n\t}\n\n\tpublic Vec2[] getParticlePositionBuffer () {\n\t\treturn m_particleSystem.getParticlePositionBuffer();\n\t}\n\n\tpublic Vec2[] getParticleVelocityBuffer () {\n\t\treturn m_particleSystem.getParticleVelocityBuffer();\n\t}\n\n\tpublic ParticleColor[] getParticleColorBuffer () {\n\t\treturn m_particleSystem.getParticleColorBuffer();\n\t}\n\n\tpublic ParticleGroup[] getParticleGroupBuffer () {\n\t\treturn m_particleSystem.getParticleGroupBuffer();\n\t}\n\n\tpublic Object[] getParticleUserDataBuffer () {\n\t\treturn m_particleSystem.getParticleUserDataBuffer();\n\t}\n\n\t/** Set a buffer for particle data.\n\t * \n\t * @param buffer is a pointer to a block of memory.\n\t * @param size is the number of values in the block. */\n\tpublic void setParticleFlagsBuffer (int[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleFlagsBuffer(buffer, capacity);\n\t}\n\n\tpublic void setParticlePositionBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticlePositionBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleVelocityBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleVelocityBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleColorBuffer (ParticleColor[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleColorBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleUserDataBuffer (Object[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleUserDataBuffer(buffer, capacity);\n\t}\n\n\t/** Get contacts between particles\n\t * \n\t * @return */\n\tpublic ParticleContact[] getParticleContacts () {\n\t\treturn m_particleSystem.m_contactBuffer;\n\t}\n\n\tpublic int getParticleContactCount () {\n\t\treturn m_particleSystem.m_contactCount;\n\t}\n\n\t/** Get contacts between particles and bodies\n\t * \n\t * @return */\n\tpublic ParticleBodyContact[] getParticleBodyContacts () {\n\t\treturn m_particleSystem.m_bodyContactBuffer;\n\t}\n\n\tpublic int getParticleBodyContactCount () {\n\t\treturn m_particleSystem.m_bodyContactCount;\n\t}\n\n\t/** Compute the kinetic energy that can be lost by damping force\n\t * \n\t * @return */\n\tpublic float computeParticleCollisionEnergy () {\n\t\treturn m_particleSystem.computeParticleCollisionEnergy();\n\t}\n}\n\nclass WorldQueryWrapper implements TreeCallback {\n\tpublic boolean treeCallback (int nodeId) {\n\t\tFixtureProxy proxy = (FixtureProxy)broadPhase.getUserData(nodeId);\n\t\treturn callback.reportFixture(proxy.fixture);\n\t}\n\n\tBroadPhase broadPhase;\n\tQueryCallback callback;\n};\n\nclass WorldRayCastWrapper implements TreeRayCastCallback {\n\n\t// djm pooling\n\tprivate final RayCastOutput output = new RayCastOutput();\n\tprivate final Vec2 temp = new Vec2();\n\tprivate final Vec2 point = new Vec2();\n\n\tpublic float raycastCallback (RayCastInput input, int nodeId) {\n\t\tObject userData = broadPhase.getUserData(nodeId);\n\t\tFixtureProxy proxy = (FixtureProxy)userData;\n\t\tFixture fixture = proxy.fixture;\n\t\tint index = proxy.childIndex;\n\t\tboolean hit = fixture.raycast(output, input, index);\n\n\t\tif (hit) {\n\t\t\tfloat fraction = output.fraction;\n\t\t\t// Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;\n\t\t\ttemp.set(input.p2).mulLocal(fraction);\n\t\t\tpoint.set(input.p1).mulLocal(1 - fraction).addLocal(temp);\n\t\t\treturn callback.reportFixture(fixture, point, output.normal, fraction);\n\t\t}\n\n\t\treturn input.maxFraction;\n\t}\n\n\tBroadPhase broadPhase;\n\tRayCastCallback callback;\n};\n")
  2270 of 2379 processed succesfully!
1
[Project Analyzer] project: libgdx
Processing libgdx...

|file:///home/dataset/libgdx/gdx/test/com/badlogic/gdx/utils/MixedPutRemoveTest.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/assets/AssetManager.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/assets/loaders/ModelLoader.java|
EmptySet()
  79 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java|
EmptySet()
  178 of 2379 processed succesfully!
  180 of 2379 processed succesfully!
  183 of 2379 processed succesfully!
  185 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java|
EmptySet()
  197 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/Cubemap.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/Texture.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/glutils/GLFrameBuffer.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java|
EmptySet()
  277 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/Environment.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/ModelCache.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java|
EmptySet()
  300 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSorter.java|
EmptySet()
  310 of 2379 processed succesfully!
  311 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleShader.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParallelArray.java|
EmptySet()
  313 of 2379 processed succesfully!
  314 of 2379 processed succesfully!
  331 of 2379 processed succesfully!
  339 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ModelInstanceParticleBatch.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java|
EmptySet()
  368 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/utils/BaseAnimationController.java|
EmptySet()
  371 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java|
EmptySet()
  377 of 2379 processed succesfully!
  392 of 2379 processed succesfully!
  403 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g2d/TextureAtlas.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPacker.java|
EmptySet()
  415 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/graphics/g2d/DistanceFieldFont.java|
EmptySet()
  440 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/math/Intersector.java|
EmptySet()
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/math/collision/OrientedBoundingBox.java|
ParseError(|unknown:///|(3189,1,<97,32>,<97,33>))
  457 of 2379 processed succesfully!
|file:///home/dataset/libgdx/gdx/src/com/badlogic/gdx/utils/Json.java|
EmptySet()
  508 of 2379 processed succesfully!
  517 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IosTestWrapper.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests-lwjgl3/src/com/badlogic/gdx/tests/lwjgl3/Lwjgl3DebugStarter.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests-lwjgl3/src/com/badlogic/gdx/tests/lwjgl3/DragNDropTest.java|
EmptySet()
  613 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/Bresenham2Test.java|
EmptySet()
  678 of 2379 processed succesfully!
  680 of 2379 processed succesfully!
  682 of 2379 processed succesfully!
  688 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/BigMeshTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/JsonTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/SelectTest.java|
EmptySet()
  767 of 2379 processed succesfully!
  776 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/OcclusionCullingTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java|
EmptySet()
  813 of 2379 processed succesfully!
  818 of 2379 processed succesfully!
  821 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/SkeletonTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MultipleRenderTargetTest.java|
EmptySet()
  829 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/FrameBufferCubemapTest.java|
EmptySet()
  836 of 2379 processed succesfully!
  838 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Animation3DTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/shadows/system/BaseShadowSystem.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/shadows/utils/AABBNearFarAnalyzer.java|
EmptySet()
  871 of 2379 processed succesfully!
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTest.java|
EmptySet()
|file:///home/dataset/libgdx/tests/gdx-tests/src/com/badlogic/gdx/tests/math/OctreeTest.java|
EmptySet()
  905 of 2379 processed succesfully!
  906 of 2379 processed succesfully!
  914 of 2379 processed succesfully!
  927 of 2379 processed succesfully!
  929 of 2379 processed succesfully!
|file:///home/dataset/libgdx/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/DefaultAndroidAudio.java|
EmptySet()
  983 of 2379 processed succesfully!
  1031 of 2379 processed succesfully!
|file:///home/dataset/libgdx/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/preloader/PreloaderBundleGenerator.java|
EmptySet()
|file:///home/dataset/libgdx/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java|
EmptySet()
|file:///home/dataset/libgdx/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java|
EmptySet()
|file:///home/dataset/libgdx/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/Lwjgl3Application.java|
EmptySet()
  1210 of 2379 processed succesfully!
  1241 of 2379 processed succesfully!
  1243 of 2379 processed succesfully!
  1287 of 2379 processed succesfully!
  1288 of 2379 processed succesfully!
  1324 of 2379 processed succesfully!
  1628 of 2379 processed succesfully!
  1725 of 2379 processed succesfully!
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/World.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/collision/RayCastOutput.java|
Ambiguity(|unknown:///|(0,1979,<1,0>,<45,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.collision;\n\nimport org.jbox2d.common.Vec2;\n\n// updated to rev 100\n/** Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from b2RayCastInput. */\npublic class RayCastOutput {\n\tpublic final Vec2 normal;\n\tpublic float fraction;\n\n\tpublic RayCastOutput () {\n\t\tnormal = new Vec2();\n\t\tfraction = 0;\n\t}\n\n\tpublic void set (final RayCastOutput rco) {\n\t\tnormal.set(rco.normal);\n\t\tfraction = rco.fraction;\n\t}\n};\n")
|file:///home/dataset/libgdx/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/org/jbox2d/dynamics/World.java|
Ambiguity(|unknown:///|(0,56587,<1,0>,<1895,0>),"CompilationUnit","/*******************************************************************************\n * Copyright (c) 2013, Daniel Murphy\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \t* Redistributions of source code must retain the above copyright notice,\n * \t  this list of conditions and the following disclaimer.\n * \t* Redistributions in binary form must reproduce the above copyright notice,\n * \t  this list of conditions and the following disclaimer in the documentation\n * \t  and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\npackage org.jbox2d.dynamics;\n\nimport org.jbox2d.callbacks.ContactFilter;\nimport org.jbox2d.callbacks.ContactListener;\nimport org.jbox2d.callbacks.DebugDraw;\nimport org.jbox2d.callbacks.DestructionListener;\nimport org.jbox2d.callbacks.ParticleDestructionListener;\nimport org.jbox2d.callbacks.ParticleQueryCallback;\nimport org.jbox2d.callbacks.ParticleRaycastCallback;\nimport org.jbox2d.callbacks.QueryCallback;\nimport org.jbox2d.callbacks.RayCastCallback;\nimport org.jbox2d.callbacks.TreeCallback;\nimport org.jbox2d.callbacks.TreeRayCastCallback;\nimport org.jbox2d.collision.AABB;\nimport org.jbox2d.collision.RayCastInput;\nimport org.jbox2d.collision.RayCastOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIInput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutput;\nimport org.jbox2d.collision.TimeOfImpact.TOIOutputState;\nimport org.jbox2d.collision.broadphase.BroadPhase;\nimport org.jbox2d.collision.broadphase.BroadPhaseStrategy;\nimport org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer;\nimport org.jbox2d.collision.broadphase.DynamicTree;\nimport org.jbox2d.collision.shapes.ChainShape;\nimport org.jbox2d.collision.shapes.CircleShape;\nimport org.jbox2d.collision.shapes.EdgeShape;\nimport org.jbox2d.collision.shapes.PolygonShape;\nimport org.jbox2d.collision.shapes.Shape;\nimport org.jbox2d.collision.shapes.ShapeType;\nimport org.jbox2d.common.Color3f;\nimport org.jbox2d.common.MathUtils;\nimport org.jbox2d.common.Settings;\nimport org.jbox2d.common.Sweep;\nimport org.jbox2d.common.Timer;\nimport org.jbox2d.common.Transform;\nimport org.jbox2d.common.Vec2;\nimport org.jbox2d.dynamics.contacts.Contact;\nimport org.jbox2d.dynamics.contacts.ContactEdge;\nimport org.jbox2d.dynamics.contacts.ContactRegister;\nimport org.jbox2d.dynamics.joints.Joint;\nimport org.jbox2d.dynamics.joints.JointDef;\nimport org.jbox2d.dynamics.joints.JointEdge;\nimport org.jbox2d.dynamics.joints.PulleyJoint;\nimport org.jbox2d.particle.ParticleBodyContact;\nimport org.jbox2d.particle.ParticleColor;\nimport org.jbox2d.particle.ParticleContact;\nimport org.jbox2d.particle.ParticleDef;\nimport org.jbox2d.particle.ParticleGroup;\nimport org.jbox2d.particle.ParticleGroupDef;\nimport org.jbox2d.particle.ParticleSystem;\nimport org.jbox2d.pooling.IDynamicStack;\nimport org.jbox2d.pooling.IWorldPool;\nimport org.jbox2d.pooling.arrays.Vec2Array;\nimport org.jbox2d.pooling.normal.DefaultWorldPool;\n\n/** The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient\n * memory management facilities.\n * \n * @author Daniel Murphy */\npublic class World {\n\tpublic static final int WORLD_POOL_SIZE = 100;\n\tpublic static final int WORLD_POOL_CONTAINER_SIZE = 10;\n\n\tpublic static final int NEW_FIXTURE = 0x0001;\n\tpublic static final int LOCKED = 0x0002;\n\tpublic static final int CLEAR_FORCES = 0x0004;\n\n\t// statistics gathering\n\tpublic int activeContacts = 0;\n\tpublic int contactPoolCount = 0;\n\n\tprotected int m_flags;\n\n\tprotected ContactManager m_contactManager;\n\n\tprivate Body m_bodyList;\n\tprivate Joint m_jointList;\n\n\tprivate int m_bodyCount;\n\tprivate int m_jointCount;\n\n\tprivate final Vec2 m_gravity = new Vec2();\n\tprivate boolean m_allowSleep;\n\n\t// private Body m_groundBody;\n\n\tprivate DestructionListener m_destructionListener;\n\tprivate ParticleDestructionListener m_particleDestructionListener;\n\tprivate DebugDraw m_debugDraw;\n\n\tprivate final IWorldPool pool;\n\n\t/** This is used to compute the time step ratio to support a variable time step. */\n\tprivate float m_inv_dt0;\n\n\t// these are for debugging the solver\n\tprivate boolean m_warmStarting;\n\tprivate boolean m_continuousPhysics;\n\tprivate boolean m_subStepping;\n\n\tprivate boolean m_stepComplete;\n\n\tprivate Profile m_profile;\n\n\tprivate ParticleSystem m_particleSystem;\n\n\tprivate ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity, IWorldPool pool) {\n\t\tthis(gravity, pool, new DynamicTree());\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhaseStrategy strategy) {\n\t\tthis(gravity, pool, new DefaultBroadPhaseBuffer(strategy));\n\t}\n\n\tpublic World (Vec2 gravity, IWorldPool pool, BroadPhase broadPhase) {\n\t\tthis.pool = pool;\n\t\tm_destructionListener = null;\n\t\tm_debugDraw = null;\n\n\t\tm_bodyList = null;\n\t\tm_jointList = null;\n\n\t\tm_bodyCount = 0;\n\t\tm_jointCount = 0;\n\n\t\tm_warmStarting = true;\n\t\tm_continuousPhysics = true;\n\t\tm_subStepping = false;\n\t\tm_stepComplete = true;\n\n\t\tm_allowSleep = true;\n\t\tm_gravity.set(gravity);\n\n\t\tm_flags = CLEAR_FORCES;\n\n\t\tm_inv_dt0 = 0f;\n\n\t\tm_contactManager = new ContactManager(this, broadPhase);\n\t\tm_profile = new Profile();\n\n\t\tm_particleSystem = new ParticleSystem(this);\n\n\t\tinitializeRegisters();\n\t}\n\n\tpublic void setAllowSleep (boolean flag) {\n\t\tif (flag == m_allowSleep) {\n\t\t\treturn;\n\t\t}\n\n\t\tm_allowSleep = flag;\n\t\tif (m_allowSleep == false) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.setAwake(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSubStepping (boolean subStepping) {\n\t\tthis.m_subStepping = subStepping;\n\t}\n\n\tpublic boolean isSubStepping () {\n\t\treturn m_subStepping;\n\t}\n\n\tpublic boolean isAllowSleep () {\n\t\treturn m_allowSleep;\n\t}\n\n\tprivate void addType (IDynamicStack\<Contact\> creator, ShapeType type1, ShapeType type2) {\n\t\tContactRegister register = new ContactRegister();\n\t\tregister.creator = creator;\n\t\tregister.primary = true;\n\t\tcontactStacks[type1.ordinal()][type2.ordinal()] = register;\n\n\t\tif (type1 != type2) {\n\t\t\tContactRegister register2 = new ContactRegister();\n\t\t\tregister2.creator = creator;\n\t\t\tregister2.primary = false;\n\t\t\tcontactStacks[type2.ordinal()][type1.ordinal()] = register2;\n\t\t}\n\t}\n\n\tprivate void initializeRegisters () {\n\t\taddType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);\n\t\taddType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);\n\t\taddType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);\n\t\taddType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);\n\t\taddType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);\n\t\taddType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);\n\t}\n\n\tpublic DestructionListener getDestructionListener () {\n\t\treturn m_destructionListener;\n\t}\n\n\tpublic ParticleDestructionListener getParticleDestructionListener () {\n\t\treturn m_particleDestructionListener;\n\t}\n\n\tpublic void setParticleDestructionListener (ParticleDestructionListener listener) {\n\t\tm_particleDestructionListener = listener;\n\t}\n\n\tpublic Contact popContact (Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {\n\t\tfinal ShapeType type1 = fixtureA.getType();\n\t\tfinal ShapeType type2 = fixtureB.getType();\n\n\t\tfinal ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];\n\t\tif (reg != null) {\n\t\t\tif (reg.primary) {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureA, indexA, fixtureB, indexB);\n\t\t\t\treturn c;\n\t\t\t} else {\n\t\t\t\tContact c = reg.creator.pop();\n\t\t\t\tc.init(fixtureB, indexB, fixtureA, indexA);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void pushContact (Contact contact) {\n\t\tFixture fixtureA = contact.getFixtureA();\n\t\tFixture fixtureB = contact.getFixtureB();\n\n\t\tif (contact.m_manifold.pointCount \> 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {\n\t\t\tfixtureA.getBody().setAwake(true);\n\t\t\tfixtureB.getBody().setAwake(true);\n\t\t}\n\n\t\tShapeType type1 = fixtureA.getType();\n\t\tShapeType type2 = fixtureB.getType();\n\n\t\tIDynamicStack\<Contact\> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;\n\t\tcreator.push(contact);\n\t}\n\n\tpublic IWorldPool getPool () {\n\t\treturn pool;\n\t}\n\n\t/** Register a destruction listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setDestructionListener (DestructionListener listener) {\n\t\tm_destructionListener = listener;\n\t}\n\n\t/** Register a contact filter to provide specific control over collision. Otherwise the default filter is used\n\t * (_defaultFilter). The listener is owned by you and must remain in scope.\n\t * \n\t * @param filter */\n\tpublic void setContactFilter (ContactFilter filter) {\n\t\tm_contactManager.m_contactFilter = filter;\n\t}\n\n\t/** Register a contact event listener. The listener is owned by you and must remain in scope.\n\t * \n\t * @param listener */\n\tpublic void setContactListener (ContactListener listener) {\n\t\tm_contactManager.m_contactListener = listener;\n\t}\n\n\t/** Register a routine for debug drawing. The debug draw functions are called inside with World.DrawDebugData method. The debug\n\t * draw object is owned by you and must remain in scope.\n\t * \n\t * @param debugDraw */\n\tpublic void setDebugDraw (DebugDraw debugDraw) {\n\t\tm_debugDraw = debugDraw;\n\t}\n\n\t/** create a rigid body given a definition. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Body createBody (BodyDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\t// TODO djm pooling\n\t\tBody b = new Body(def, this);\n\n\t\t// add to world doubly linked list\n\t\tb.m_prev = null;\n\t\tb.m_next = m_bodyList;\n\t\tif (m_bodyList != null) {\n\t\t\tm_bodyList.m_prev = b;\n\t\t}\n\t\tm_bodyList = b;\n\t\t++m_bodyCount;\n\n\t\treturn b;\n\t}\n\n\t/** destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during\n\t * callbacks.\n\t * \n\t * @warning This automatically deletes all associated shapes and joints.\n\t * @warning This function is locked during callbacks.\n\t * @param body */\n\tpublic void destroyBody (Body body) {\n\t\tassert (m_bodyCount \> 0);\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete the attached joints.\n\t\tJointEdge je = body.m_jointList;\n\t\twhile (je != null) {\n\t\t\tJointEdge je0 = je;\n\t\t\tje = je.next;\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(je0.joint);\n\t\t\t}\n\n\t\t\tdestroyJoint(je0.joint);\n\n\t\t\tbody.m_jointList = je;\n\t\t}\n\t\tbody.m_jointList = null;\n\n\t\t// Delete the attached contacts.\n\t\tContactEdge ce = body.m_contactList;\n\t\twhile (ce != null) {\n\t\t\tContactEdge ce0 = ce;\n\t\t\tce = ce.next;\n\t\t\tm_contactManager.destroy(ce0.contact);\n\t\t}\n\t\tbody.m_contactList = null;\n\n\t\tFixture f = body.m_fixtureList;\n\t\twhile (f != null) {\n\t\t\tFixture f0 = f;\n\t\t\tf = f.m_next;\n\n\t\t\tif (m_destructionListener != null) {\n\t\t\t\tm_destructionListener.sayGoodbye(f0);\n\t\t\t}\n\n\t\t\tf0.destroyProxies(m_contactManager.m_broadPhase);\n\t\t\tf0.destroy();\n\t\t\t// TODO djm recycle fixtures (here or in that destroy method)\n\t\t\tbody.m_fixtureList = f;\n\t\t\tbody.m_fixtureCount -= 1;\n\t\t}\n\t\tbody.m_fixtureList = null;\n\t\tbody.m_fixtureCount = 0;\n\n\t\t// Remove world body list.\n\t\tif (body.m_prev != null) {\n\t\t\tbody.m_prev.m_next = body.m_next;\n\t\t}\n\n\t\tif (body.m_next != null) {\n\t\t\tbody.m_next.m_prev = body.m_prev;\n\t\t}\n\n\t\tif (body == m_bodyList) {\n\t\t\tm_bodyList = body.m_next;\n\t\t}\n\n\t\t--m_bodyCount;\n\t\t// TODO djm recycle body\n\t}\n\n\t/** create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected\n\t * bodies to cease colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param def\n\t * @return */\n\tpublic Joint createJoint (JointDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tJoint j = Joint.create(this, def);\n\n\t\t// Connect to the world list.\n\t\tj.m_prev = null;\n\t\tj.m_next = m_jointList;\n\t\tif (m_jointList != null) {\n\t\t\tm_jointList.m_prev = j;\n\t\t}\n\t\tm_jointList = j;\n\t\t++m_jointCount;\n\n\t\t// Connect to the bodies\' doubly linked lists.\n\t\tj.m_edgeA.joint = j;\n\t\tj.m_edgeA.other = j.getBodyB();\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = j.getBodyA().m_jointList;\n\t\tif (j.getBodyA().m_jointList != null) {\n\t\t\tj.getBodyA().m_jointList.prev = j.m_edgeA;\n\t\t}\n\t\tj.getBodyA().m_jointList = j.m_edgeA;\n\n\t\tj.m_edgeB.joint = j;\n\t\tj.m_edgeB.other = j.getBodyA();\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = j.getBodyB().m_jointList;\n\t\tif (j.getBodyB().m_jointList != null) {\n\t\t\tj.getBodyB().m_jointList.prev = j.m_edgeB;\n\t\t}\n\t\tj.getBodyB().m_jointList = j.m_edgeB;\n\n\t\tBody bodyA = def.bodyA;\n\t\tBody bodyB = def.bodyB;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (def.collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\n\t\t// Note: creating a joint doesn\'t wake the bodies.\n\n\t\treturn j;\n\t}\n\n\t/** destroy a joint. This may cause the connected bodies to begin colliding.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @param joint */\n\tpublic void destroyJoint (Joint j) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\n\t\tboolean collideConnected = j.getCollideConnected();\n\n\t\t// Remove from the doubly linked list.\n\t\tif (j.m_prev != null) {\n\t\t\tj.m_prev.m_next = j.m_next;\n\t\t}\n\n\t\tif (j.m_next != null) {\n\t\t\tj.m_next.m_prev = j.m_prev;\n\t\t}\n\n\t\tif (j == m_jointList) {\n\t\t\tm_jointList = j.m_next;\n\t\t}\n\n\t\t// Disconnect from island graph.\n\t\tBody bodyA = j.getBodyA();\n\t\tBody bodyB = j.getBodyB();\n\n\t\t// Wake up connected bodies.\n\t\tbodyA.setAwake(true);\n\t\tbodyB.setAwake(true);\n\n\t\t// Remove from body 1.\n\t\tif (j.m_edgeA.prev != null) {\n\t\t\tj.m_edgeA.prev.next = j.m_edgeA.next;\n\t\t}\n\n\t\tif (j.m_edgeA.next != null) {\n\t\t\tj.m_edgeA.next.prev = j.m_edgeA.prev;\n\t\t}\n\n\t\tif (j.m_edgeA == bodyA.m_jointList) {\n\t\t\tbodyA.m_jointList = j.m_edgeA.next;\n\t\t}\n\n\t\tj.m_edgeA.prev = null;\n\t\tj.m_edgeA.next = null;\n\n\t\t// Remove from body 2\n\t\tif (j.m_edgeB.prev != null) {\n\t\t\tj.m_edgeB.prev.next = j.m_edgeB.next;\n\t\t}\n\n\t\tif (j.m_edgeB.next != null) {\n\t\t\tj.m_edgeB.next.prev = j.m_edgeB.prev;\n\t\t}\n\n\t\tif (j.m_edgeB == bodyB.m_jointList) {\n\t\t\tbodyB.m_jointList = j.m_edgeB.next;\n\t\t}\n\n\t\tj.m_edgeB.prev = null;\n\t\tj.m_edgeB.next = null;\n\n\t\tJoint.destroy(j);\n\n\t\tassert (m_jointCount \> 0);\n\t\t--m_jointCount;\n\n\t\t// If the joint prevents collisions, then flag any contacts for filtering.\n\t\tif (collideConnected == false) {\n\t\t\tContactEdge edge = bodyB.getContactList();\n\t\t\twhile (edge != null) {\n\t\t\t\tif (edge.other == bodyA) {\n\t\t\t\t\t// Flag the contact for filtering at the next time step (where either\n\t\t\t\t\t// body is awake).\n\t\t\t\t\tedge.contact.flagForFiltering();\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\t\t\t}\n\t\t}\n\t}\n\n\t// djm pooling\n\tprivate final TimeStep step = new TimeStep();\n\tprivate final Timer stepTimer = new Timer();\n\tprivate final Timer tempTimer = new Timer();\n\n\t/** Take a time step. This performs collision detection, integration, and constraint solution.\n\t * \n\t * @param timeStep the amount of time to simulate, this should not vary.\n\t * @param velocityIterations for the velocity constraint solver.\n\t * @param positionIterations for the position constraint solver. */\n\tpublic void step (float dt, int velocityIterations, int positionIterations) {\n\t\tstepTimer.reset();\n\t\ttempTimer.reset();\n\t\t// log.debug(\"Starting step\");\n\t\t// If new fixtures were added, we need to find the new contacts.\n\t\tif ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\n\t\t\t// log.debug(\"There\'s a new fixture, lets look for new contacts\");\n\t\t\tm_contactManager.findNewContacts();\n\t\t\tm_flags &= ~NEW_FIXTURE;\n\t\t}\n\n\t\tm_flags |= LOCKED;\n\n\t\tstep.dt = dt;\n\t\tstep.velocityIterations = velocityIterations;\n\t\tstep.positionIterations = positionIterations;\n\t\tif (dt \> 0.0f) {\n\t\t\tstep.inv_dt = 1.0f / dt;\n\t\t} else {\n\t\t\tstep.inv_dt = 0.0f;\n\t\t}\n\n\t\tstep.dtRatio = m_inv_dt0 * dt;\n\n\t\tstep.warmStarting = m_warmStarting;\n\t\tm_profile.stepInit.record(tempTimer.getMilliseconds());\n\n\t\t// Update contacts. This is where some contacts are destroyed.\n\t\ttempTimer.reset();\n\t\tm_contactManager.collide();\n\t\tm_profile.collide.record(tempTimer.getMilliseconds());\n\n\t\t// Integrate velocities, solve velocity constraints, and integrate positions.\n\t\tif (m_stepComplete && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tm_particleSystem.solve(step); // Particle Simulation\n\t\t\tm_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\n\t\t\ttempTimer.reset();\n\t\t\tsolve(step);\n\t\t\tm_profile.solve.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\t// Handle TOI events.\n\t\tif (m_continuousPhysics && step.dt \> 0.0f) {\n\t\t\ttempTimer.reset();\n\t\t\tsolveTOI(step);\n\t\t\tm_profile.solveTOI.record(tempTimer.getMilliseconds());\n\t\t}\n\n\t\tif (step.dt \> 0.0f) {\n\t\t\tm_inv_dt0 = step.inv_dt;\n\t\t}\n\n\t\tif ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\n\t\t\tclearForces();\n\t\t}\n\n\t\tm_flags &= ~LOCKED;\n\t\t// log.debug(\"ending step\");\n\n\t\tm_profile.step.record(stepTimer.getMilliseconds());\n\t}\n\n\t/** Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless\n\t * you are performing sub-steps. By default, forces will be automatically cleared, so you don\'t need to call this function.\n\t * \n\t * @see setAutoClearForces */\n\tpublic void clearForces () {\n\t\tfor (Body body = m_bodyList; body != null; body = body.getNext()) {\n\t\t\tbody.m_force.setZero();\n\t\t\tbody.m_torque = 0.0f;\n\t\t}\n\t}\n\n\tprivate final Color3f color = new Color3f();\n\tprivate final Transform xf = new Transform();\n\tprivate final Vec2 cA = new Vec2();\n\tprivate final Vec2 cB = new Vec2();\n\tprivate final Vec2Array avs = new Vec2Array();\n\n\t/** Call this to draw shapes and other debug draw data. */\n\tpublic void drawDebugData () {\n\t\tif (m_debugDraw == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint flags = m_debugDraw.getFlags();\n\t\tboolean wireframe = (flags & DebugDraw.e_wireframeDrawingBit) != 0;\n\n\t\tif ((flags & DebugDraw.e_shapeBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.STATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.9f, 0.3f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.getType() == BodyType.KINEMATIC) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.9f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else if (b.isAwake() == false) {\n\t\t\t\t\t\tcolor.set(0.5f, 0.5f, 0.5f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolor.set(0.9f, 0.7f, 0.7f);\n\t\t\t\t\t\tdrawShape(f, xf, color, wireframe);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawParticleSystem(m_particleSystem);\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_jointBit) != 0) {\n\t\t\tfor (Joint j = m_jointList; j != null; j = j.getNext()) {\n\t\t\t\tdrawJoint(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_pairBit) != 0) {\n\t\t\tcolor.set(0.3f, 0.9f, 0.9f);\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.getNext()) {\n\t\t\t\tFixture fixtureA = c.getFixtureA();\n\t\t\t\tFixture fixtureB = c.getFixtureB();\n\t\t\t\tfixtureA.getAABB(c.getChildIndexA()).getCenterToOut(cA);\n\t\t\t\tfixtureB.getAABB(c.getChildIndexB()).getCenterToOut(cB);\n\t\t\t\tm_debugDraw.drawSegment(cA, cB, color);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_aabbBit) != 0) {\n\t\t\tcolor.set(0.9f, 0.3f, 0.9f);\n\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\tif (b.isActive() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (Fixture f = b.getFixtureList(); f != null; f = f.getNext()) {\n\t\t\t\t\tfor (int i = 0; i \< f.m_proxyCount; ++i) {\n\t\t\t\t\t\tFixtureProxy proxy = f.m_proxies[i];\n\t\t\t\t\t\tAABB aabb = m_contactManager.m_broadPhase.getFatAABB(proxy.proxyId);\n\t\t\t\t\t\tif (aabb != null) {\n\t\t\t\t\t\t\tVec2[] vs = avs.get(4);\n\t\t\t\t\t\t\tvs[0].set(aabb.lowerBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[1].set(aabb.upperBound.x, aabb.lowerBound.y);\n\t\t\t\t\t\t\tvs[2].set(aabb.upperBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tvs[3].set(aabb.lowerBound.x, aabb.upperBound.y);\n\t\t\t\t\t\t\tm_debugDraw.drawPolygon(vs, 4, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_centerOfMassBit) != 0) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t\txf.set(b.getTransform());\n\t\t\t\txf.p.set(b.getWorldCenter());\n\t\t\t\tm_debugDraw.drawTransform(xf);\n\t\t\t}\n\t\t}\n\n\t\tif ((flags & DebugDraw.e_dynamicTreeBit) != 0) {\n\t\t\tm_contactManager.m_broadPhase.drawTree(m_debugDraw);\n\t\t}\n\n\t\tm_debugDraw.flush();\n\t}\n\n\tprivate final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();\n\n\t/** Query the world for all fixtures that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t}\n\n\t/** Query the world for all fixtures and particles that potentially overlap the provided AABB.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {\n\t\twqwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twqwrapper.callback = callback;\n\t\tm_contactManager.m_broadPhase.query(wqwrapper, aabb);\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\t/** Query the world for all particles that potentially overlap the provided AABB.\n\t * \n\t * @param particleCallback callback for particles.\n\t * @param aabb the query box. */\n\tpublic void queryAABB (ParticleQueryCallback particleCallback, AABB aabb) {\n\t\tm_particleSystem.queryAABB(particleCallback, aabb);\n\t}\n\n\tprivate final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();\n\tprivate final RayCastInput input = new RayCastInput();\n\n\t/** Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t}\n\n\t/** Ray-cast the world for all fixtures and particles in the path of the ray. Your callback controls whether you get the\n\t * closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.\n\t * \n\t * @param callback a user implemented callback class.\n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\twrcwrapper.broadPhase = m_contactManager.m_broadPhase;\n\t\twrcwrapper.callback = callback;\n\t\tinput.maxFraction = 1.0f;\n\t\tinput.p1.set(point1);\n\t\tinput.p2.set(point2);\n\t\tm_contactManager.m_broadPhase.raycast(wrcwrapper, input);\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Ray-cast the world for all particles in the path of the ray. Your callback controls whether you get the closest point, any\n\t * point, or n-points.\n\t * \n\t * @param particleCallback the particle callback class.\n\t * @param point1 the ray starting point\n\t * @param point2 the ray ending point */\n\tpublic void raycast (ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {\n\t\tm_particleSystem.raycast(particleCallback, point1, point2);\n\t}\n\n\t/** Get the world body list. With the returned body, use Body.getNext to get the next body in the world list. A null body\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world body list. */\n\tpublic Body getBodyList () {\n\t\treturn m_bodyList;\n\t}\n\n\t/** Get the world joint list. With the returned joint, use Joint.getNext to get the next joint in the world list. A null joint\n\t * indicates the end of the list.\n\t * \n\t * @return the head of the world joint list. */\n\tpublic Joint getJointList () {\n\t\treturn m_jointList;\n\t}\n\n\t/** Get the world contact list. With the returned contact, use Contact.getNext to get the next contact in the world list. A\n\t * null contact indicates the end of the list.\n\t * \n\t * @return the head of the world contact list.\n\t * @warning contacts are created and destroyed in the middle of a time step. Use ContactListener to avoid missing contacts. */\n\tpublic Contact getContactList () {\n\t\treturn m_contactManager.m_contactList;\n\t}\n\n\tpublic boolean isSleepingAllowed () {\n\t\treturn m_allowSleep;\n\t}\n\n\tpublic void setSleepingAllowed (boolean sleepingAllowed) {\n\t\tm_allowSleep = sleepingAllowed;\n\t}\n\n\t/** Enable/disable warm starting. For testing.\n\t * \n\t * @param flag */\n\tpublic void setWarmStarting (boolean flag) {\n\t\tm_warmStarting = flag;\n\t}\n\n\tpublic boolean isWarmStarting () {\n\t\treturn m_warmStarting;\n\t}\n\n\t/** Enable/disable continuous physics. For testing.\n\t * \n\t * @param flag */\n\tpublic void setContinuousPhysics (boolean flag) {\n\t\tm_continuousPhysics = flag;\n\t}\n\n\tpublic boolean isContinuousPhysics () {\n\t\treturn m_continuousPhysics;\n\t}\n\n\t/** Get the number of broad-phase proxies.\n\t * \n\t * @return */\n\tpublic int getProxyCount () {\n\t\treturn m_contactManager.m_broadPhase.getProxyCount();\n\t}\n\n\t/** Get the number of bodies.\n\t * \n\t * @return */\n\tpublic int getBodyCount () {\n\t\treturn m_bodyCount;\n\t}\n\n\t/** Get the number of joints.\n\t * \n\t * @return */\n\tpublic int getJointCount () {\n\t\treturn m_jointCount;\n\t}\n\n\t/** Get the number of contacts (each may have 0 or more contact points).\n\t * \n\t * @return */\n\tpublic int getContactCount () {\n\t\treturn m_contactManager.m_contactCount;\n\t}\n\n\t/** Gets the height of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeHeight () {\n\t\treturn m_contactManager.m_broadPhase.getTreeHeight();\n\t}\n\n\t/** Gets the balance of the dynamic tree\n\t * \n\t * @return */\n\tpublic int getTreeBalance () {\n\t\treturn m_contactManager.m_broadPhase.getTreeBalance();\n\t}\n\n\t/** Gets the quality of the dynamic tree\n\t * \n\t * @return */\n\tpublic float getTreeQuality () {\n\t\treturn m_contactManager.m_broadPhase.getTreeQuality();\n\t}\n\n\t/** Change the global gravity vector.\n\t * \n\t * @param gravity */\n\tpublic void setGravity (Vec2 gravity) {\n\t\tm_gravity.set(gravity);\n\t}\n\n\t/** Get the global gravity vector.\n\t * \n\t * @return */\n\tpublic Vec2 getGravity () {\n\t\treturn m_gravity;\n\t}\n\n\t/** Is the world locked (in the middle of a time step).\n\t * \n\t * @return */\n\tpublic boolean isLocked () {\n\t\treturn (m_flags & LOCKED) == LOCKED;\n\t}\n\n\t/** Set flag to control automatic clearing of forces after each time step.\n\t * \n\t * @param flag */\n\tpublic void setAutoClearForces (boolean flag) {\n\t\tif (flag) {\n\t\t\tm_flags |= CLEAR_FORCES;\n\t\t} else {\n\t\t\tm_flags &= ~CLEAR_FORCES;\n\t\t}\n\t}\n\n\t/** Get the flag that controls automatic clearing of forces after each time step.\n\t * \n\t * @return */\n\tpublic boolean getAutoClearForces () {\n\t\treturn (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\n\t}\n\n\t/** Get the contact manager for testing purposes\n\t * \n\t * @return */\n\tpublic ContactManager getContactManager () {\n\t\treturn m_contactManager;\n\t}\n\n\tpublic Profile getProfile () {\n\t\treturn m_profile;\n\t}\n\n\tprivate final Island island = new Island();\n\tprivate Body[] stack = new Body[10]; // TODO djm find a good initial stack number;\n\tprivate final Timer broadphaseTimer = new Timer();\n\n\tprivate void solve (TimeStep step) {\n\t\tm_profile.solveInit.startAccum();\n\t\tm_profile.solveVelocity.startAccum();\n\t\tm_profile.solvePosition.startAccum();\n\n\t\t// update previous transforms\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_xf0.set(b.m_xf);\n\t\t}\n\n\t\t// Size the island for the worst case.\n\t\tisland.init(m_bodyCount, m_contactManager.m_contactCount, m_jointCount, m_contactManager.m_contactListener);\n\n\t\t// Clear all the island flags.\n\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t}\n\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\tc.m_flags &= ~Contact.ISLAND_FLAG;\n\t\t}\n\t\tfor (Joint j = m_jointList; j != null; j = j.m_next) {\n\t\t\tj.m_islandFlag = false;\n\t\t}\n\n\t\t// Build and simulate all awake islands.\n\t\tint stackSize = m_bodyCount;\n\t\tif (stack.length \< stackSize) {\n\t\t\tstack = new Body[stackSize];\n\t\t}\n\t\tfor (Body seed = m_bodyList; seed != null; seed = seed.m_next) {\n\t\t\tif ((seed.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (seed.isAwake() == false || seed.isActive() == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The seed can be dynamic or kinematic.\n\t\t\tif (seed.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Reset island and stack.\n\t\t\tisland.clear();\n\t\t\tint stackCount = 0;\n\t\t\tstack[stackCount++] = seed;\n\t\t\tseed.m_flags |= Body.e_islandFlag;\n\n\t\t\t// Perform a depth first search (DFS) on the constraint graph.\n\t\t\twhile (stackCount \> 0) {\n\t\t\t\t// Grab the next body off the stack and add it to the island.\n\t\t\t\tBody b = stack[--stackCount];\n\t\t\t\tassert (b.isActive() == true);\n\t\t\t\tisland.add(b);\n\n\t\t\t\t// Make sure the body is awake.\n\t\t\t\tb.setAwake(true);\n\n\t\t\t\t// To keep islands as small as possible, we don\'t\n\t\t\t\t// propagate islands across static bodies.\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Search all contacts connected to this body.\n\t\t\t\tfor (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t// Has this contact already been added to an island?\n\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Is this contact solid and touching?\n\t\t\t\t\tif (contact.isEnabled() == false || contact.isTouching() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip sensors.\n\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(contact);\n\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t\t\tBody other = ce.other;\n\n\t\t\t\t\t// Was the other body already added to this island?\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\n\t\t\t\t// Search all joints connect to this body.\n\t\t\t\tfor (JointEdge je = b.m_jointList; je != null; je = je.next) {\n\t\t\t\t\tif (je.joint.m_islandFlag == true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody other = je.other;\n\n\t\t\t\t\t// Don\'t simulate joints connected to inactive bodies.\n\t\t\t\t\tif (other.isActive() == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tisland.add(je.joint);\n\t\t\t\t\tje.joint.m_islandFlag = true;\n\n\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == Body.e_islandFlag) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (stackCount \< stackSize);\n\t\t\t\t\tstack[stackCount++] = other;\n\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tisland.solve(m_profile, step, m_gravity, m_allowSleep);\n\n\t\t\t// Post solve cleanup.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\t// Allow static bodies to participate in other islands.\n\t\t\t\tBody b = island.m_bodies[i];\n\t\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm_profile.solveInit.endAccum();\n\t\tm_profile.solveVelocity.endAccum();\n\t\tm_profile.solvePosition.endAccum();\n\n\t\tbroadphaseTimer.reset();\n\t\t// Synchronize fixtures, check for out of range bodies.\n\t\tfor (Body b = m_bodyList; b != null; b = b.getNext()) {\n\t\t\t// If a body was not in an island then it did not move.\n\t\t\tif ((b.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (b.getType() == BodyType.STATIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Update fixtures (for broad-phase).\n\t\t\tb.synchronizeFixtures();\n\t\t}\n\n\t\t// Look for new contacts.\n\t\tm_contactManager.findNewContacts();\n\t\tm_profile.broadphase.record(broadphaseTimer.getMilliseconds());\n\t}\n\n\tprivate final Island toiIsland = new Island();\n\tprivate final TOIInput toiInput = new TOIInput();\n\tprivate final TOIOutput toiOutput = new TOIOutput();\n\tprivate final TimeStep subStep = new TimeStep();\n\tprivate final Body[] tempBodies = new Body[2];\n\tprivate final Sweep backup1 = new Sweep();\n\tprivate final Sweep backup2 = new Sweep();\n\n\tprivate void solveTOI (final TimeStep step) {\n\n\t\tfinal Island island = toiIsland;\n\t\tisland.init(2 * Settings.maxTOIContacts, Settings.maxTOIContacts, 0, m_contactManager.m_contactListener);\n\t\tif (m_stepComplete) {\n\t\t\tfor (Body b = m_bodyList; b != null; b = b.m_next) {\n\t\t\t\tb.m_flags &= ~Body.e_islandFlag;\n\t\t\t\tb.m_sweep.alpha0 = 0.0f;\n\t\t\t}\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Invalidate TOI\n\t\t\t\tc.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\tc.m_toiCount = 0;\n\t\t\t\tc.m_toi = 1.0f;\n\t\t\t}\n\t\t}\n\n\t\t// Find TOI events and solve them.\n\t\tfor (;;) {\n\t\t\t// Find the first TOI.\n\t\t\tContact minContact = null;\n\t\t\tfloat minAlpha = 1.0f;\n\n\t\t\tfor (Contact c = m_contactManager.m_contactList; c != null; c = c.m_next) {\n\t\t\t\t// Is this contact disabled?\n\t\t\t\tif (c.isEnabled() == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Prevent excessive sub-stepping.\n\t\t\t\tif (c.m_toiCount \> Settings.maxSubSteps) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat alpha = 1.0f;\n\t\t\t\tif ((c.m_flags & Contact.TOI_FLAG) != 0) {\n\t\t\t\t\t// This contact has a valid cached TOI.\n\t\t\t\t\talpha = c.m_toi;\n\t\t\t\t} else {\n\t\t\t\t\tFixture fA = c.getFixtureA();\n\t\t\t\t\tFixture fB = c.getFixtureB();\n\n\t\t\t\t\t// Is there a sensor?\n\t\t\t\t\tif (fA.isSensor() || fB.isSensor()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tBody bA = fA.getBody();\n\t\t\t\t\tBody bB = fB.getBody();\n\n\t\t\t\t\tBodyType typeA = bA.m_type;\n\t\t\t\t\tBodyType typeB = bB.m_type;\n\t\t\t\t\tassert (typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC);\n\n\t\t\t\t\tboolean activeA = bA.isAwake() && typeA != BodyType.STATIC;\n\t\t\t\t\tboolean activeB = bB.isAwake() && typeB != BodyType.STATIC;\n\n\t\t\t\t\t// Is at least one body active (awake and dynamic or kinematic)?\n\t\t\t\t\tif (activeA == false && activeB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;\n\t\t\t\t\tboolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;\n\n\t\t\t\t\t// Are these two non-bullet dynamic bodies?\n\t\t\t\t\tif (collideA == false && collideB == false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute the TOI for this contact.\n\t\t\t\t\t// Put the sweeps onto the same time interval.\n\t\t\t\t\tfloat alpha0 = bA.m_sweep.alpha0;\n\n\t\t\t\t\tif (bA.m_sweep.alpha0 \< bB.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bB.m_sweep.alpha0;\n\t\t\t\t\t\tbA.m_sweep.advance(alpha0);\n\t\t\t\t\t} else if (bB.m_sweep.alpha0 \< bA.m_sweep.alpha0) {\n\t\t\t\t\t\talpha0 = bA.m_sweep.alpha0;\n\t\t\t\t\t\tbB.m_sweep.advance(alpha0);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert (alpha0 \< 1.0f);\n\n\t\t\t\t\tint indexA = c.getChildIndexA();\n\t\t\t\t\tint indexB = c.getChildIndexB();\n\n\t\t\t\t\t// Compute the time of impact in interval [0, minTOI]\n\t\t\t\t\tfinal TOIInput input = toiInput;\n\t\t\t\t\tinput.proxyA.set(fA.getShape(), indexA);\n\t\t\t\t\tinput.proxyB.set(fB.getShape(), indexB);\n\t\t\t\t\tinput.sweepA.set(bA.m_sweep);\n\t\t\t\t\tinput.sweepB.set(bB.m_sweep);\n\t\t\t\t\tinput.tMax = 1.0f;\n\n\t\t\t\t\tpool.getTimeOfImpact().timeOfImpact(toiOutput, input);\n\n\t\t\t\t\t// Beta is the fraction of the remaining portion of the .\n\t\t\t\t\tfloat beta = toiOutput.t;\n\t\t\t\t\tif (toiOutput.state == TOIOutputState.TOUCHING) {\n\t\t\t\t\t\talpha = MathUtils.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\talpha = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.m_toi = alpha;\n\t\t\t\t\tc.m_flags |= Contact.TOI_FLAG;\n\t\t\t\t}\n\n\t\t\t\tif (alpha \< minAlpha) {\n\t\t\t\t\t// This is the minimum TOI found so far.\n\t\t\t\t\tminContact = c;\n\t\t\t\t\tminAlpha = alpha;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minContact == null || 1.0f - 10.0f * Settings.EPSILON \< minAlpha) {\n\t\t\t\t// No more TOI events. Done!\n\t\t\t\tm_stepComplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Advance the bodies to the TOI.\n\t\t\tFixture fA = minContact.getFixtureA();\n\t\t\tFixture fB = minContact.getFixtureB();\n\t\t\tBody bA = fA.getBody();\n\t\t\tBody bB = fB.getBody();\n\n\t\t\tbackup1.set(bA.m_sweep);\n\t\t\tbackup2.set(bB.m_sweep);\n\n\t\t\tbA.advance(minAlpha);\n\t\t\tbB.advance(minAlpha);\n\n\t\t\t// The TOI contact likely has some new contact points.\n\t\t\tminContact.update(m_contactManager.m_contactListener);\n\t\t\tminContact.m_flags &= ~Contact.TOI_FLAG;\n\t\t\t++minContact.m_toiCount;\n\n\t\t\t// Is the contact solid?\n\t\t\tif (minContact.isEnabled() == false || minContact.isTouching() == false) {\n\t\t\t\t// Restore the sweeps.\n\t\t\t\tminContact.setEnabled(false);\n\t\t\t\tbA.m_sweep.set(backup1);\n\t\t\t\tbB.m_sweep.set(backup2);\n\t\t\t\tbA.synchronizeTransform();\n\t\t\t\tbB.synchronizeTransform();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbA.setAwake(true);\n\t\t\tbB.setAwake(true);\n\n\t\t\t// Build the island\n\t\t\tisland.clear();\n\t\t\tisland.add(bA);\n\t\t\tisland.add(bB);\n\t\t\tisland.add(minContact);\n\n\t\t\tbA.m_flags |= Body.e_islandFlag;\n\t\t\tbB.m_flags |= Body.e_islandFlag;\n\t\t\tminContact.m_flags |= Contact.ISLAND_FLAG;\n\n\t\t\t// Get contacts on bodyA and bodyB.\n\t\t\ttempBodies[0] = bA;\n\t\t\ttempBodies[1] = bB;\n\t\t\tfor (int i = 0; i \< 2; ++i) {\n\t\t\t\tBody body = tempBodies[i];\n\t\t\t\tif (body.m_type == BodyType.DYNAMIC) {\n\t\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\t\tif (island.m_bodyCount == island.m_bodyCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (island.m_contactCount == island.m_contactCapacity) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tContact contact = ce.contact;\n\n\t\t\t\t\t\t// Has this contact already been added to the island?\n\t\t\t\t\t\tif ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only add static, kinematic, or bullet bodies.\n\t\t\t\t\t\tBody other = ce.other;\n\t\t\t\t\t\tif (other.m_type == BodyType.DYNAMIC && body.isBullet() == false && other.isBullet() == false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Skip sensors.\n\t\t\t\t\t\tboolean sensorA = contact.m_fixtureA.m_isSensor;\n\t\t\t\t\t\tboolean sensorB = contact.m_fixtureB.m_isSensor;\n\t\t\t\t\t\tif (sensorA || sensorB) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Tentatively advance the body to the TOI.\n\t\t\t\t\t\tbackup1.set(other.m_sweep);\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) == 0) {\n\t\t\t\t\t\t\tother.advance(minAlpha);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the contact points\n\t\t\t\t\t\tcontact.update(m_contactManager.m_contactListener);\n\n\t\t\t\t\t\t// Was the contact disabled by the user?\n\t\t\t\t\t\tif (contact.isEnabled() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Are there contact points?\n\t\t\t\t\t\tif (contact.isTouching() == false) {\n\t\t\t\t\t\t\tother.m_sweep.set(backup1);\n\t\t\t\t\t\t\tother.synchronizeTransform();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the contact to the island\n\t\t\t\t\t\tcontact.m_flags |= Contact.ISLAND_FLAG;\n\t\t\t\t\t\tisland.add(contact);\n\n\t\t\t\t\t\t// Has the other body already been added to the island?\n\t\t\t\t\t\tif ((other.m_flags & Body.e_islandFlag) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add the other body to the island.\n\t\t\t\t\t\tother.m_flags |= Body.e_islandFlag;\n\n\t\t\t\t\t\tif (other.m_type != BodyType.STATIC) {\n\t\t\t\t\t\t\tother.setAwake(true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tisland.add(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsubStep.dt = (1.0f - minAlpha) * step.dt;\n\t\t\tsubStep.inv_dt = 1.0f / subStep.dt;\n\t\t\tsubStep.dtRatio = 1.0f;\n\t\t\tsubStep.positionIterations = 20;\n\t\t\tsubStep.velocityIterations = step.velocityIterations;\n\t\t\tsubStep.warmStarting = false;\n\t\t\tisland.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\n\n\t\t\t// Reset island flags and synchronize broad-phase proxies.\n\t\t\tfor (int i = 0; i \< island.m_bodyCount; ++i) {\n\t\t\t\tBody body = island.m_bodies[i];\n\t\t\t\tbody.m_flags &= ~Body.e_islandFlag;\n\n\t\t\t\tif (body.m_type != BodyType.DYNAMIC) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbody.synchronizeFixtures();\n\n\t\t\t\t// Invalidate all contact TOIs on this displaced body.\n\t\t\t\tfor (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {\n\t\t\t\t\tce.contact.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commit fixture proxy movements to the broad-phase so that new contacts are created.\n\t\t\t// Also, some contacts can be destroyed.\n\t\t\tm_contactManager.findNewContacts();\n\n\t\t\tif (m_subStepping) {\n\t\t\t\tm_stepComplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void drawJoint (Joint joint) {\n\t\tBody bodyA = joint.getBodyA();\n\t\tBody bodyB = joint.getBodyB();\n\t\tTransform xf1 = bodyA.getTransform();\n\t\tTransform xf2 = bodyB.getTransform();\n\t\tVec2 x1 = xf1.p;\n\t\tVec2 x2 = xf2.p;\n\t\tVec2 p1 = pool.popVec2();\n\t\tVec2 p2 = pool.popVec2();\n\t\tjoint.getAnchorA(p1);\n\t\tjoint.getAnchorB(p2);\n\n\t\tcolor.set(0.5f, 0.8f, 0.8f);\n\n\t\tswitch (joint.getType()) {\n\t\t// TODO djm write after writing joints\n\t\tcase DISTANCE:\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tbreak;\n\n\t\tcase PULLEY: {\n\t\t\tPulleyJoint pulley = (PulleyJoint)joint;\n\t\t\tVec2 s1 = pulley.getGroundAnchorA();\n\t\t\tVec2 s2 = pulley.getGroundAnchorB();\n\t\t\tm_debugDraw.drawSegment(s1, p1, color);\n\t\t\tm_debugDraw.drawSegment(s2, p2, color);\n\t\t\tm_debugDraw.drawSegment(s1, s2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CONSTANT_VOLUME:\n\t\tcase MOUSE:\n\t\t\t// don\'t draw this\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tm_debugDraw.drawSegment(x1, p1, color);\n\t\t\tm_debugDraw.drawSegment(p1, p2, color);\n\t\t\tm_debugDraw.drawSegment(x2, p2, color);\n\t\t}\n\t\tpool.pushVec2(2);\n\t}\n\n\t// NOTE this corresponds to the liquid test, so the debugdraw can draw\n\t// the liquid particles correctly. They should be the same.\n\tprivate static Integer LIQUID_INT = new Integer(1234598372);\n\tprivate float liquidLength = .12f;\n\tprivate float averageLinearVel = -1;\n\tprivate final Vec2 liquidOffset = new Vec2();\n\tprivate final Vec2 circCenterMoved = new Vec2();\n\tprivate final Color3f liquidColor = new Color3f(.4f, .4f, 1f);\n\n\tprivate final Vec2 center = new Vec2();\n\tprivate final Vec2 axis = new Vec2();\n\tprivate final Vec2 v1 = new Vec2();\n\tprivate final Vec2 v2 = new Vec2();\n\tprivate final Vec2Array tlvertices = new Vec2Array();\n\n\tprivate void drawShape (Fixture fixture, Transform xf, Color3f color, boolean wireframe) {\n\t\tswitch (fixture.getType()) {\n\t\tcase CIRCLE: {\n\t\t\tCircleShape circle = (CircleShape)fixture.getShape();\n\n\t\t\t// Vec2 center = Mul(xf, circle.m_p);\n\t\t\tTransform.mulToOutUnsafe(xf, circle.m_p, center);\n\t\t\tfloat radius = circle.m_radius;\n\t\t\txf.q.getXAxis(axis);\n\n\t\t\tif (fixture.getUserData() != null && fixture.getUserData().equals(LIQUID_INT)) {\n\t\t\t\tBody b = fixture.getBody();\n\t\t\t\tliquidOffset.set(b.m_linearVelocity);\n\t\t\t\tfloat linVelLength = b.m_linearVelocity.length();\n\t\t\t\tif (averageLinearVel == -1) {\n\t\t\t\t\taverageLinearVel = linVelLength;\n\t\t\t\t} else {\n\t\t\t\t\taverageLinearVel = .98f * averageLinearVel + .02f * linVelLength;\n\t\t\t\t}\n\t\t\t\tliquidOffset.mulLocal(liquidLength / averageLinearVel / 2);\n\t\t\t\tcircCenterMoved.set(center).addLocal(liquidOffset);\n\t\t\t\tcenter.subLocal(liquidOffset);\n\t\t\t\tm_debugDraw.drawSegment(center, circCenterMoved, liquidColor);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawCircle(center, radius, axis, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidCircle(center, radius, axis, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase POLYGON: {\n\t\t\tPolygonShape poly = (PolygonShape)fixture.getShape();\n\t\t\tint vertexCount = poly.m_count;\n\t\t\tassert (vertexCount \<= Settings.maxPolygonVertices);\n\t\t\tVec2[] vertices = tlvertices.get(Settings.maxPolygonVertices);\n\n\t\t\tfor (int i = 0; i \< vertexCount; ++i) {\n\t\t\t\t// vertices[i] = Mul(xf, poly.m_vertices[i]);\n\t\t\t\tTransform.mulToOutUnsafe(xf, poly.m_vertices[i], vertices[i]);\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawPolygon(vertices, vertexCount, color);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawSolidPolygon(vertices, vertexCount, color);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase EDGE: {\n\t\t\tEdgeShape edge = (EdgeShape)fixture.getShape();\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex1, v1);\n\t\t\tTransform.mulToOutUnsafe(xf, edge.m_vertex2, v2);\n\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t}\n\t\t\tbreak;\n\t\tcase CHAIN: {\n\t\t\tChainShape chain = (ChainShape)fixture.getShape();\n\t\t\tint count = chain.m_count;\n\t\t\tVec2[] vertices = chain.m_vertices;\n\n\t\t\tTransform.mulToOutUnsafe(xf, vertices[0], v1);\n\t\t\tfor (int i = 1; i \< count; ++i) {\n\t\t\t\tTransform.mulToOutUnsafe(xf, vertices[i], v2);\n\t\t\t\tm_debugDraw.drawSegment(v1, v2, color);\n\t\t\t\tm_debugDraw.drawCircle(v1, 0.05f, color);\n\t\t\t\tv1.set(v2);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void drawParticleSystem (ParticleSystem system) {\n\t\tboolean wireframe = (m_debugDraw.getFlags() & DebugDraw.e_wireframeDrawingBit) != 0;\n\t\tint particleCount = system.getParticleCount();\n\t\tif (particleCount != 0) {\n\t\t\tfloat particleRadius = system.getParticleRadius();\n\t\t\tVec2[] positionBuffer = system.getParticlePositionBuffer();\n\t\t\tParticleColor[] colorBuffer = null;\n\t\t\tif (system.m_colorBuffer.data != null) {\n\t\t\t\tcolorBuffer = system.getParticleColorBuffer();\n\t\t\t}\n\t\t\tif (wireframe) {\n\t\t\t\tm_debugDraw.drawParticlesWireframe(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t} else {\n\t\t\t\tm_debugDraw.drawParticles(positionBuffer, particleRadius, colorBuffer, particleCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Create a particle whose properties have been defined. No reference to the definition is retained. A simulation step must\n\t * occur before it\'s possible to interact with a newly created particle. For example, DestroyParticleInShape() will not destroy\n\t * a particle until Step() has been called.\n\t * \n\t * @warning This function is locked during callbacks.\n\t * @return the index of the particle. */\n\tpublic int createParticle (ParticleDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint p = m_particleSystem.createParticle(def);\n\t\treturn p;\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param index */\n\tpublic void destroyParticle (int index) {\n\t\tdestroyParticle(index, false);\n\t}\n\n\t/** Destroy a particle. The particle is removed after the next step.\n\t * \n\t * @param Index of the particle to destroy.\n\t * @param Whether to call the destruction listener just before the particle is destroyed. */\n\tpublic void destroyParticle (int index, boolean callDestructionListener) {\n\t\tm_particleSystem.destroyParticle(index, callDestructionListener);\n\t}\n\n\t/** Destroy particles inside a shape without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks. For more information see DestroyParticleInShape(Shape&, Transform&,bool).\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf) {\n\t\treturn destroyParticlesInShape(shape, xf, false);\n\t}\n\n\t/** Destroy particles inside a shape. This function is locked during callbacks. In addition, this function immediately destroys\n\t * particles in the shape in contrast to DestroyParticle() which defers the destruction until the next simulation step.\n\t * \n\t * @param Shape which encloses particles that should be destroyed.\n\t * @param Transform applied to the shape.\n\t * @param Whether to call the world b2DestructionListener for each particle destroyed.\n\t * @warning This function is locked during callbacks.\n\t * @return Number of particles destroyed. */\n\tpublic int destroyParticlesInShape (Shape shape, Transform xf, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn m_particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);\n\t}\n\n\t/** Create a particle group whose properties have been defined. No reference to the definition is retained.\n\t * \n\t * @warning This function is locked during callbacks. */\n\tpublic ParticleGroup createParticleGroup (ParticleGroupDef def) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn null;\n\t\t}\n\t\tParticleGroup g = m_particleSystem.createParticleGroup(def);\n\t\treturn g;\n\t}\n\n\t/** Join two particle groups.\n\t * \n\t * @param the first group. Expands to encompass the second group.\n\t * @param the second group. It is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void joinParticleGroups (ParticleGroup groupA, ParticleGroup groupB) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.joinParticleGroups(groupA, groupB);\n\t}\n\n\t/** Destroy particles in a group. This function is locked during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @param Whether to call the world b2DestructionListener for each particle is destroyed.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group, boolean callDestructionListener) {\n\t\tassert (isLocked() == false);\n\t\tif (isLocked()) {\n\t\t\treturn;\n\t\t}\n\t\tm_particleSystem.destroyParticlesInGroup(group, callDestructionListener);\n\t}\n\n\t/** Destroy particles in a group without enabling the destruction callback for destroyed particles. This function is locked\n\t * during callbacks.\n\t * \n\t * @param The particle group to destroy.\n\t * @warning This function is locked during callbacks. */\n\tpublic void destroyParticlesInGroup (ParticleGroup group) {\n\t\tdestroyParticlesInGroup(group, false);\n\t}\n\n\t/** Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get the next group in the world\n\t * list. A NULL group indicates the end of the list.\n\t * \n\t * @return the head of the world particle group list. */\n\tpublic ParticleGroup[] getParticleGroupList () {\n\t\treturn m_particleSystem.getParticleGroupList();\n\t}\n\n\t/** Get the number of particle groups.\n\t * \n\t * @return */\n\tpublic int getParticleGroupCount () {\n\t\treturn m_particleSystem.getParticleGroupCount();\n\t}\n\n\t/** Get the number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleCount () {\n\t\treturn m_particleSystem.getParticleCount();\n\t}\n\n\t/** Get the maximum number of particles.\n\t * \n\t * @return */\n\tpublic int getParticleMaxCount () {\n\t\treturn m_particleSystem.getParticleMaxCount();\n\t}\n\n\t/** Set the maximum number of particles.\n\t * \n\t * @param count */\n\tpublic void setParticleMaxCount (int count) {\n\t\tm_particleSystem.setParticleMaxCount(count);\n\t}\n\n\t/** Change the particle density.\n\t * \n\t * @param density */\n\tpublic void setParticleDensity (float density) {\n\t\tm_particleSystem.setParticleDensity(density);\n\t}\n\n\t/** Get the particle density.\n\t * \n\t * @return */\n\tpublic float getParticleDensity () {\n\t\treturn m_particleSystem.getParticleDensity();\n\t}\n\n\t/** Change the particle gravity scale. Adjusts the effect of the global gravity vector on particles. Default value is 1.0f.\n\t * \n\t * @param gravityScale */\n\tpublic void setParticleGravityScale (float gravityScale) {\n\t\tm_particleSystem.setParticleGravityScale(gravityScale);\n\n\t}\n\n\t/** Get the particle gravity scale.\n\t * \n\t * @return */\n\tpublic float getParticleGravityScale () {\n\t\treturn m_particleSystem.getParticleGravityScale();\n\t}\n\n\t/** Damping is used to reduce the velocity of particles. The damping parameter can be larger than 1.0f but the damping effect\n\t * becomes sensitive to the time step when the damping parameter is large.\n\t * \n\t * @param damping */\n\tpublic void setParticleDamping (float damping) {\n\t\tm_particleSystem.setParticleDamping(damping);\n\t}\n\n\t/** Get damping for particles\n\t * \n\t * @return */\n\tpublic float getParticleDamping () {\n\t\treturn m_particleSystem.getParticleDamping();\n\t}\n\n\t/** Change the particle radius. You should set this only once, on world start. If you change the radius during execution,\n\t * existing particles may explode, shrink, or behave unexpectedly.\n\t * \n\t * @param radius */\n\tpublic void setParticleRadius (float radius) {\n\t\tm_particleSystem.setParticleRadius(radius);\n\t}\n\n\t/** Get the particle radius.\n\t * \n\t * @return */\n\tpublic float getParticleRadius () {\n\t\treturn m_particleSystem.getParticleRadius();\n\t}\n\n\t/** Get the particle data. @return the pointer to the head of the particle data.\n\t * \n\t * @return */\n\tpublic int[] getParticleFlagsBuffer () {\n\t\treturn m_particleSystem.getParticleFlagsBuffer();\n\t}\n\n\tpublic Vec2[] getParticlePositionBuffer () {\n\t\treturn m_particleSystem.getParticlePositionBuffer();\n\t}\n\n\tpublic Vec2[] getParticleVelocityBuffer () {\n\t\treturn m_particleSystem.getParticleVelocityBuffer();\n\t}\n\n\tpublic ParticleColor[] getParticleColorBuffer () {\n\t\treturn m_particleSystem.getParticleColorBuffer();\n\t}\n\n\tpublic ParticleGroup[] getParticleGroupBuffer () {\n\t\treturn m_particleSystem.getParticleGroupBuffer();\n\t}\n\n\tpublic Object[] getParticleUserDataBuffer () {\n\t\treturn m_particleSystem.getParticleUserDataBuffer();\n\t}\n\n\t/** Set a buffer for particle data.\n\t * \n\t * @param buffer is a pointer to a block of memory.\n\t * @param size is the number of values in the block. */\n\tpublic void setParticleFlagsBuffer (int[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleFlagsBuffer(buffer, capacity);\n\t}\n\n\tpublic void setParticlePositionBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticlePositionBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleVelocityBuffer (Vec2[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleVelocityBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleColorBuffer (ParticleColor[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleColorBuffer(buffer, capacity);\n\n\t}\n\n\tpublic void setParticleUserDataBuffer (Object[] buffer, int capacity) {\n\t\tm_particleSystem.setParticleUserDataBuffer(buffer, capacity);\n\t}\n\n\t/** Get contacts between particles\n\t * \n\t * @return */\n\tpublic ParticleContact[] getParticleContacts () {\n\t\treturn m_particleSystem.m_contactBuffer;\n\t}\n\n\tpublic int getParticleContactCount () {\n\t\treturn m_particleSystem.m_contactCount;\n\t}\n\n\t/** Get contacts between particles and bodies\n\t * \n\t * @return */\n\tpublic ParticleBodyContact[] getParticleBodyContacts () {\n\t\treturn m_particleSystem.m_bodyContactBuffer;\n\t}\n\n\tpublic int getParticleBodyContactCount () {\n\t\treturn m_particleSystem.m_bodyContactCount;\n\t}\n\n\t/** Compute the kinetic energy that can be lost by damping force\n\t * \n\t * @return */\n\tpublic float computeParticleCollisionEnergy () {\n\t\treturn m_particleSystem.computeParticleCollisionEnergy();\n\t}\n}\n\nclass WorldQueryWrapper implements TreeCallback {\n\tpublic boolean treeCallback (int nodeId) {\n\t\tFixtureProxy proxy = (FixtureProxy)broadPhase.getUserData(nodeId);\n\t\treturn callback.reportFixture(proxy.fixture);\n\t}\n\n\tBroadPhase broadPhase;\n\tQueryCallback callback;\n};\n\nclass WorldRayCastWrapper implements TreeRayCastCallback {\n\n\t// djm pooling\n\tprivate final RayCastOutput output = new RayCastOutput();\n\tprivate final Vec2 temp = new Vec2();\n\tprivate final Vec2 point = new Vec2();\n\n\tpublic float raycastCallback (RayCastInput input, int nodeId) {\n\t\tObject userData = broadPhase.getUserData(nodeId);\n\t\tFixtureProxy proxy = (FixtureProxy)userData;\n\t\tFixture fixture = proxy.fixture;\n\t\tint index = proxy.childIndex;\n\t\tboolean hit = fixture.raycast(output, input, index);\n\n\t\tif (hit) {\n\t\t\tfloat fraction = output.fraction;\n\t\t\t// Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;\n\t\t\ttemp.set(input.p2).mulLocal(fraction);\n\t\t\tpoint.set(input.p1).mulLocal(1 - fraction).addLocal(temp);\n\t\t\treturn callback.reportFixture(fixture, point, output.normal, fraction);\n\t\t}\n\n\t\treturn input.maxFraction;\n\t}\n\n\tBroadPhase broadPhase;\n\tRayCastCallback callback;\n};\n")
|file:///home/dataset/libgdx/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-setup/src/com/badlogic/gdx/setup/ProjectBuilder.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/FileProcessor.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/Chart.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/GradientPanel.java|
EmptySet()
  2232 of 2379 processed succesfully!
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/EffectPanel.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/FlameMain.java|
EmptySet()
  2250 of 2379 processed succesfully!
  2251 of 2379 processed succesfully!
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/GradientPanel.java|
EmptySet()
  2255 of 2379 processed succesfully!
  2256 of 2379 processed succesfully!
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TexturePanel.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EffectPanel.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/unicodefont/UnicodeFont.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePackerTest.java|
EmptySet()
|file:///home/dataset/libgdx/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePackerFileProcessor.java|
EmptySet()
58
INFO:root:  Formating the source code
INFO:root:   Done
